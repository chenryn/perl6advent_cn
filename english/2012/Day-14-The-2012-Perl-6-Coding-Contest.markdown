For the third year in a row, let's write some Perl 6 contest code!

**The 2012 Perl 6 Coding Contest**

Perl 6 has had a great year, with its two major implementations growing increasingly mature. Sometimes it's easy to forget all the progress that happens each month. Features and performance have improved all through the year. I think that will show in this year's entries.

So here's what's happening:

**do five tasks, and you might win Amazon books worth €100!**

The contest starts _now_, today on 2012-12-14. It ends five weeks later, on 2013-01-18. Registration is open for two weeks, starting _now_. Just send an email to `cmasak@gmail.com` — saying "sign me up!" or even sending your Amazon wishlist so I'll know which books to buy you if you win.

You might be curious about what you need to do to win. Here's an extract from the file [`rules.md`](https://github.com/masak/p6cc2012/blob/master/rules.md):

    
    Since "code quality" is a slightly subjective measure, let us provide a few hints of what we'll be looking for:
    
    * Correctness.
    * Readability.
    * Consistency.
    * Clarity of intent.
    * Algorithmic efficiency.
    * Idiomatic use of Perl 6.
    * Brevity.
    
    In short, what we're looking for is top-quality code. That's how you win.
    

Here are the five tasks. Write Perl 6 programs to...

  * Tell knights from knaves based on what they say. [(more)](http://github.com/masak/p6cc2012/blob/master/t1/description.md)
  * Generate rectangle haikus. [(more)](http://github.com/masak/p6cc2012/blob/master/t2/description.md)
  * Arrange wire crossings to rearrange wires. [(more)](http://github.com/masak/p6cc2012/blob/master/t3/description.md)
  * Simulate rain in a world of cubes. [(more)](http://github.com/masak/p6cc2012/blob/master/t4/description.md)
  * Distribute weights in bags evenly. [(more)](http://github.com/masak/p6cc2012/blob/master/t5/description.md)

I've chosen the problems so that they're easy to explain, but allow contestants quite a bit of freedom to play around with various solutions.

This time, the whole contest is running as a [GitHub repository](http://github.com/masak/p6cc2012). Easier than hosting zip files.

Now sign up — you've nothing to lose, and books to win! Also, this is your chance to finally take a look at Perl 6. 哈哈

_[December 14, 2012 20:21](http://strangelyconsistent.org/blog/the-2012-perl-6-coding-contest)_

### [Perl 6 Advent Calendar](http://perl6advent.wordpress.com) -- [Primal Needs](http://perl6advent.wordpress.com/2012/12/14/primal-needs/)

Our brains are hard-wired to look for patterns, even where none exist. So, it’s no surprise that as soon as mankind started counting things, he would look for patterns in numbers. One group of numbers that have resisted the pattern matching capabilities of the human brain are the so-called “prime numbers”. These are numbers that can only be evenly divided by 1 or themselves–they have no other factors.

But you knew that already, so why am I talking about prime numbers instead of Perl 6? Because, just like our ancestors, the people that created Perl 6 and continue to shape it to be around for the next 100 years or more find prime numbers interesting. So interesting, in fact, that the language specification was modified to include a routine for determining whether or not a number is prime.

## Alpha

At first, implmementations of this prime-number-finder were pure Perl 6 and took advantage of other features of the language such as ranges and junctions. An example implementation is shown below:

        sub is-prime($n) { $n %% none 2..sqrt $n }

This implementation checks to see that none of numbers from 2 to the square root of `$n` will evenly divide `$n`. If this is the case, then the number is prime.

While the above implementation works fine, it is a little slow and it does suffer a little redundancy in the numbers it checks. For instance, if you know a number isn’t evenly divisible by 2, there’s no need to check if it’s evenly divisible by 4, yet the above algorithm does so anyway.

## Beta

An improvement on the algorithm is to only check if the I between 2 and the square root of the number evenly divide the number. But … but … that’s like like defining a word in terms of itself. Thanks to ubiquitous lazy evaluation in Perl 6, that’s entirely possible. Here’s an implementation:

    
        my @primes := 2, 3, 5, -> $p { ($p+2, $p+4 ... &is-prime)[*-1] } ... *;
        sub is-prime($n) { $n %% none @primes ...^  * > sqrt $n }
    

The array `@primes` is an infinite, lazily evaluated sequence of numbers starting with 2, 3, and 5. The next number in the sequence is generated by creating a new sequence of odd numbers that start from the last odd number and continue until we reach a prime. That prime is the next number in the sequence. But how do we know if it’s a prime? We check with our handy C subroutine that actually uses the lazy list of primes up to the square root of the number we’re testing to see if any of them are factors.

There’s a kind of mutual recursion going on here where the `@primes` array effectively memoizes the primes we’ve seen so far. But … then there’s the problem that `@primes` will continue to grow as you check bigger and bigger numbers for prime-ness. Can we do better?

Indeed we can.

## Gamma: Rabin-Miller test

Well … _maybe_ we can. It depends on your idea of “better”. The [Rabin-Miller primality test](http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test) is probabalistic in nature. It doesn’t require storing an ever increasing cache of prime numbers to test if they are factors of the potential prime, but there is a chance that it will tell you that a number is prime when it actually isn’t. The good news is that we can adjust the odds so that we are reasonably confident that the number is prime. Here’s an implementation (taken from [http://rosettacode.org/wiki/Miller-Rabin_primality_test#Perl_6](http://rosettacode.org/wiki/Miller-Rabin_primality_test#Perl_6)):

    
    sub expmod(Int $a is copy, Int $b is copy, $n) {
    	my $c = 1;
    	repeat while $b div= 2 {
    		($c *= $a) %= $n if $b % 2;
    		($a *= $a) %= $n;
    	}
    	$c;
    }
     
    subset PrimeCandidate of Int where { $_ > 2 and $_ % 2 };
     
    my Bool multi sub is-prime(Int $n, Int $k)            { return False; }
    my Bool multi sub is-prime(2, Int $k)                 { return True; }
    my Bool multi sub is-prime(PrimeCandidate $n, Int $k) {
    	my Int $d = $n - 1;
    	my Int $s = 0;
     
    	while $d %% 2 {(PrimeCandidate $n, Int $k)
    		$d div= 2;
    		$s++;
    	}
     
    	for (2 ..^ $n).pick($k) -> $a {
    		my $x = expmod($a, $d, $n);
     
    		next if $x == 1 or $x == $n - 1;
     
    		for 1 ..^ $s {
    			$x = $x ** 2 mod $n;
    			return False if $x == 1;
    			last if $x == $n - 1;
    		}
    		return False if $x !== $n - 1;
    	}
     
    	return True;
    }
    

The third multi variant of `is-prime` with the signature `(PrimeCandidate $n, Int $k)` is where all of the magic happens. This multi is only triggered when the prime candidate (`$n`) is an odd number because of the definition of the `PrimeCandidate` type.

First, we factor out the powers of 2 from `$n - 1`. Since `$n` is an odd number, `$n - 1` is even and so has at least one factor of 2. What we end up with is an odd number and some power-of-2 factors of `$n - 1`. We then use those factors to see if a random sample of `$k` numbers less than `$n` are congruent to the square roots of unity modulo `$n` (`expmod` handles the modular exponentiation). We repeat this for all of the powers of 2 we factored out of the original number. [Fermat’s little theorem](http://en.wikipedia.org/wiki/Fermat's_little_theorem) says that if we find any number where the congruence does **not** hold, then the number can not be prime.

The probability that this method will select a composite number as prime is based on how many numbers less than `$n` we choose to sample. If we select `$k` numbers to try, the probability is `4 ** -$k`. By choosing to sample more numbers, we can quickly decrease the odds of a false positive to a negligible amount.

## Wrap up

But … most people don’t really have to worry about the implementation details of `is-prime`. Not only have `is-prime` and `expmod` been added to the Perl 6 specification, but actual implementations (ala Rabin-Miller) have been added to the Rakudo and Niecza Perl 6 compilers. So, if you want to test your new cryptographic algorithm and need some large prime numbers, or if you’re developing a new random number generator and need some candidates for the modulus, or maybe you’re developing a new hashing algorithm, Perl 6 has a built-in `is-prime` that can help.

