<div class="post" id="post-">
特征(Traits)是一个很好的，可扩展的方式给Perl6里各种对象加上元数据。
<br />
举一个例子比如cached的特征是它会自动的缓存函数的返回值，当然这有赖于传递给他的参数设置。
<br />
下面是一个简单的具体实现：
<br />
<pre>
# 这段代码在子例程被添加了'is cached'时被调用
multi sub trait_mod:<is>(Routine $r, :$cached!) {
    my %cache;
    # 包装一个代码块
    $r.wrap(-> $arg {
        # 检查是否已有缓存值
        %cache.exists($arg)
            ?? %cache{$arg}
            # 调用原值或者记录缓存
            !! (%cache{$arg} = callwith($arg))
        }
    );
}

# 示例子例程
sub fib($x) is cached {
    say("fib($x)");
    $x <= 1 ?? 1 !! fib($x - 1) + fib($x - 2);
}
# 从0到10，只会调用一次
say fib(10);
</pre>
这里特征被认定为一个动词。这个动词出现在子例程的名字后面以处理这个特征，具体到例子里就是trait_mod:<is>。这个处理程序的参数，则是将要运用这个特征的对象，以及作为命名参数的特征的具体名字。
<br />
注意：从产品级角度看，这个cached很可能会需要处理好几个参数，也许像限制缓存大小的等等......
<br />
在这里例子里，子例程上调用了.wrap方法。当然你也可以改用其他什么~常见的做法，是把角色(role)混合进子例程里，或者是把他们加进调度表里。
<br />
特征不单单用于子例程，也可以用于参数、属性和变量。比如下面代码就是用'is rw'特征来实现写访问器：
<pre>
class Book {
    has @.pages is rw;
}
</pre>
特征还可以用来给类和属性附加文档(Pod6的说明留给圣临月历的其他部分)，标记子例程参数为可写，声明类的继承和角色的应用。
<br />
这种灵活性使得他们在编写库文件的时候就像是写DSL一样，并以一种安全的方式提供元数据。
</div>
