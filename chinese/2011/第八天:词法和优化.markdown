对编译器的传统优化主要依赖于编程时对编译期的知识掌握。通常静态语言比如java和C都比较擅长这个，而动态语言像Perl5和ruby、python则相反。

Perl6提供和动态语言一样的灵活性，但也尝试提供一定的编译器优化，虽然是靠敲键盘写明可选的静态类型注释。

但即便你标明了静态类型，编译期内还有一块需要编译器调度和内联的：关于可用例程的认知（以及在多函数multi subs时提供候选）。

为了提供这个认知，Perl6在词法作用域内（而不在包和符号表内，这和Perl5一样）部署子例程。而词法作用域在运行时间内是不可变的。（词法作用域内的变量当然
还是可变的，你只是不能添加或者删除作用域内的条目）

为了提供足够的灵活性，Perl6允许在编译期运行代码。一个典型的在编译期运行代码的办法就是跟use指令写在一块：

    
    
    {
        use Test;  # 在编译期把例程导入一个正确的词法作用域
        plan 1;
        ok 1, 'success';
    }
    # 跳出作用域，plan()和ok()现在已经失效了
    

这么做的好处，是一个聪明可爱的编译器可以在运行期之前就检查成缺少例程，然后认定这个程序注定会失败。目前Rakudo就可以做到这点，虽然已知有一个情况Raku
do不会检测，但是我确信这个是可以检测的。

    
    
    sub f(Int $x) {
        say $x * 2;
    }
    say "got here";
    f('some string');
    

Rakudo运行这个代码会得到如下输出：

    
    
    ===SORRY!===
    CHECK FAILED:
    Calling 'f' will never work with argument types (str) (line 5)
        Expected: :(Int $x)
    

因为内置例程是在更外一层的作用域里提供给用户程序的，所有的内置例程都和用户自定义例程接受同样的规则和优化。

注意：这里牵扯到另一个东西--
require。require是在运行期加载模块的，但现在它需要在编译期保存一个符号表的列表。这样在之后才可以连接上那些从模块里加载上的符号表。

关于"聪明可爱的编译器"的空想时代已经过去，现在我们已经拥有一个提供可测量的加速效果的编译器。当然它依然还有提升的空间，而我们已经可以看到静态认知和词法作用
域的好处了！

