一门语言，开发者的使用经验总是比对它的设计、特性和实现的了解要多的多。虽然语言的实现也许是开发者花时间最多的地方，但是社区互动、文档阅读和各种开发工具的运用都涉及了过往的经验。所以，Perl6 也在这些方面取得了进展。在过去一年里，我们在这些领域大大的向前迈步：现在有了[doc.perl6.org](http://doc.perl6.org)，模块的生态圈继续扩大，而且模块的安装工具也改进了。另一个关于工具的大进步 - 也是本文的主题 - 就是现在有了一个交互式的 Perl6 调试器。

# 用调试器运行

最近的几次Rakudo发行版本里已经带上了调试器。如果你安装的是这其中的版本，一切都已经配置好了。直接运行 `perl6-debug` 而不是 `perl6` 就可以了。他们对参数的处理是一样的。所以你正常调用，比如说，`-I` 参数来设置模块路径的适合，它会和平常一样工作。当然，接下来发生的就不一样了。调试器会展示给你它所在加载的每个模块，然后停留在你程序的第一句，而且用黄色高亮。

![dbg0](http://img0.tuicool.com/6Rn6Bb.png)

注意它是怎样做到跳过前面的代码，把你停留在真正要做点什么事情的第一行代码那块的（在这方面调试器越来越聪明了）。

# 基础

敲回车就可以单步运行。在每一步，你斗可以察看变量，调用变量的方法，甚至计算表达式。

![dbg1](http://img1.tuicool.com/FnQJvu.png)

如果你想一句一句的执行，但又不进入函数或者方法调用，输入 `s` 然后回车。跳出当前子例程（就是说：运行到程序返回然后回到调用这个子例程的地方），使用 `so` 键。运行程序直到碰到异常为止，使用 `r` 键。即便你碰到异常了，你依然可以访问变量来分析查找问题。

![dbg2](http://img2.tuicool.com/3AzuAn.png)

一个最终的变种： `rt` 键。它会运行到异常抛出而且被处理。你会停在抛出异常的地方。这意味着即便你在程序里已经把异常处理搞的很完备了，在调试器里你依然可以随心所欲的停在异常抛出的地方，然后用调试器来帮助理解。

# 断点

有时候，你已经知道程序会在哪里出问题，而这正是你要调试的。如果你只想赶紧运行下去直到那里为止，恭喜你，断点就是用来干这个的。你可以添加一个断点，然后用 `r` 运行，它就是自动停在你设置的断点在的地方。

![dbg3](http://img0.tuicool.com/MRBBZn.png)

注意你不用输入你要加断点的文件的全名。输入的字符串可以明确具体哪个文件就足够了，调试器会自动加载的。

这里我不会多讲，但是还得说一句还有一种追踪点。到时候它不是退出而是每次运行到的适合把表达式的值记录到日志里。看起来像是加了一个print语句，但是没有真的在你的代码里加上print，这样就没有一不小心把print语句给commit（大家应该都有用commit吧）到正式代码库的风险了。

### 正则和语法调试

当调试器检测到你是在正则或者语法环境里，他会提供一点额外的帮助。不单单允许你原子粒度的单步运行正则，还会显示出匹配到的文本，指出目前位置匹配到了什么。

![dbg4](http://img1.tuicool.com/Bf6Vnm.png)

这里你可以看到正则已经成功匹配到了 SELECT，现在正在查找字符\*或者尝试调用字段列表规则。如果是在可以回溯的正则表达式里，匹配的游标在回溯发生的时候可能来回跳动。这下你可以搞懂正则里的回溯了吧。

### 是的， Perl5 正则也行！

Rakudo有些支持 :p5 风格的正则，以便你使用 Perl5 的正则语法。调试器会工作在 REPL 模式（你输入一个表达式，理解就调试它）下以探测 Perl5 和 Perl6 之间的差异（在 Perl5 中，正则是从左到右解析的，而 Perl6 里我们有最长标记匹配语义，他会尝试先匹配最多的字符串）。

![dbg5](http://img2.tuicool.com/FrAvUz.png)

在 REPL 模式下的调试器对探索和理解代码执行（还有教学）相当有用。另一个用途是可以不写测试脚本直接调试模块。只要在调试器里写一行 `use` 语句，或者使用 `-M` 命令行参数，调试器就会帮你加载模块了。

### 那些时髦玩意儿，比如宏呢？

像宏，`BEGIN` 区域， `eval` ，以及其他各种需要你的 Perl6 程序重回时光隧道，在编译时做点运行时的事情，或者运行时里编译更多东西。调试器就是为这个目标创建的。如果应用一个宏，调试器会定位到宏里。注意下面，我们停留在加载第二个文件的进程里，没有进第三个 -- 我们已经在 `BEGIN` 里就调试了。

![dbg6](http://img0.tuicool.com/rI77Nf.png)

被宏剥离出来的任何代码都不会在运行时触发。那在类似的块里的语句呢？调试器会带你到那，所以你不但可以知道应用了哪个宏，还可以深入的知道他具体干什么了。

![dbg7](http://img1.tuicool.com/iIRnQz.png)

上面在编译时的运行时代码调试成功，在运行时的用 `eval` 调用的代码也同样是带着调试钩子编译的。也就是说你可以单步运行进去然后调试代码执行。

### 用 Perl6 和 NQP 写的！

你可能以为写一个调试器需要涉及各种底层的黑客技术。事实上不是的。调试钩子机制是[用 NQP 写的](https://github.com/jnthn/rakudo-debugger/blob/master/bin/perl6-debug.nqp), 命令行用户接口是[用 Perl6 写的](https://github.com/jnthn/rakudo-debugger/blob/master/lib/Debugger/UI/CommandLine.pm)。从两方面看这是很重要的。第一，事实上我们可以不破坏编译器的封装就写出来这样的调试器，只需要搞些语法的子类，动作和编译好的对象然后摆弄 AST 。事实上，调试器创建不要求对已有的Rakudo做任何修改。这给我们的编译器架构提供了重要的反馈 -- 这次是非常积极的反馈。事情被他们设计成了可扩展的方式。第二，写这么多的 Perl6 代码算是一些成功的吃狗食 -- 使用这个产品来构建进一步的产品。我希望绝大多数人希望修改的是 Perl6 写的部分，整个社区应该会觉得很容易修改。

### 还有什么未来计划么？

各种特性还在继续出现：条件断点，导出追踪点到文件，显示语法调用路径来获取当前位置，以及各种配置项。命令行接口已经很不错了，不过当然还有些参数可以变得更好。我现在的兴趣在网页化接口，也考虑整合进像 Padre 这类工具。已经有些工作在[common protocol](https://github.com/kevindawson/Bullwinkle/wiki)下进行。这让做这类整合工作不需要发明太多新轮子就可以搞定。在这期间，做出一个运行良好的，具有广泛 Perl6 语言特性支持的交互式调试器算是向前迈出的很扎实的一步。调试开心~欢迎大家提交有关的想法（和补丁）。项目地址：[GitHub repo](https://github.com/jnthn/rakudo-debugger)!
