# Perl 5 to Perl 6

本文开始是以[一系列博客文章]的形式存在，为阅读方便收集整理而成。

## 目录

* [简介][17]
* [字符串、数组和哈希][18]
* [类型][19]
* [基础控制结构][20]
* [子例程和签名][21]
* [对象和类][22]
* [上下文][23]
* [Regexes (also called "rules")][24]
* [Junctions][25]
* [Comparing and Matching][26]
* [Containers and Values][27]
* [对 Perl 5 操作符的改变][28]
* [Laziness][29]
* [自定义操作符][30]
* [MAIN 函数][31]
* [Twigils][32]
* [Enums][33]
* [Unicode][34]
* [Scoping][35]
* [Regexes strike back][36]
* [A grammar for (pseudo) XML][37]
* [Subset Types][38]
* [The State of the implementations][39]
* [Quoting and Parsing][40]
* [The Reduction Meta Operator][41]
* [The Cross Meta Operator][42]
* [Exceptions and control exceptions][43]
* [Common Perl 6 data processing idioms][44]
* [Currying][45]

## 简介

Sat Sep 20 22:00:00 2008

### NAME

"Perl 5 to 6" - 介绍

### 概要

    学习 Perl 6 ( 假设你已经了解 Perl 5 )
    学会欣赏Perl 6 
    知道为什么

### 描述

Perl 6 目前文档不足. 这并不奇怪, 因为编写 Perl 6 的编译器比写文档这事 ( 目前只有一个 specification 规范 ) 这个对于用户来讲更加重要多了.

不幸的是, 这意味着会让大家不太容易学习 Perl 6, 除非你是对 Perl 6 有比较深入的关注的人, 就算这样, 目前也就只能从 specification, IRC 和测试套件中学习.

这个项目, 初步给名字定为 "Perl 5 to 6"(目前我找不到更好的名字) 来填补文档空白这个事情.

这个课程都内容都会保持矮小精悍. 我会试图用很短的例子来解释 2-3 个重点. 也会解释从 Perl 5 变成 Perl 6 的改进, 这一点非常重要. 我希望你通过读这些课程学到所需要的知识. 

这些内容都是 Synopses 中的, 这是 Perl 智慧的来源和汇总.

为了保证读起来方便, 每个课程会控制在不超过 200 行或者 1000 个单词 ( 当然就是个软限制 );

这个对于学习编程语言也许太短了. 但我希望是讲出语言的设计的目标, 让你看到它强大并美丽的一面, 并且不用按语言大纲就能很快的学习并使用.

### [IT'S NOT]

这并不是一个 Perl 5 转成 Perl 6 的指南, 所以没有完整的转换列表.

### [文章路线图]

已经在写了的和准备要写的:

    00 Intro
    01 Strings, Arrays, Hashes
    02 Types
    03 Control structures
    04 Subs and Signatures
    05 Objects and Classes
    06 Contexts
    07 Rules
    08 Junctions
    09 Comparisons and Smartmatching
    10 Containers and Binding
    11 Basic Operators
    12 Laziness (-)
    13 Custom Operators (-)
    14 the MAIN sub
    15 Twigils
    16 Enums
    17 Unicode (-)
    18 Scoping
    19 More Regexes
    20 A Grammar for XML
    21 Subset types
    22 State of the Implementations
    23 Quoting and Parsing (-)
    24 Recude meta operator
    25 Cross meta operator
    26 Exceptions and control exceptions

( 有些不是或者目前 Rakudo 没有实现完的内容标了一个 `(-)`)

有些东西我想写, 但我对这些的了解还不够:

    Macros
    Meta Object Programming
    Concurrency
    IO

这个东西, 我想提到, 但不知道放在那个地方合适

    .perl method

我也会更新这些课程, 也保证他们不是太落伍了.

### [AUTHOR]

Moritz Lenz, <http://perlgeek.de/>, `moritz@faui2k3.org`

### [LINKS]

Other documentation efforts can be found on <http://perl6.org/documentation/>.

## 字符串、数组和哈希

Sat Sep 20 22:20:00 2008

### [NAME]

"Perl 5 to 6" 第 1 课 - 字符串、数组和哈希

### 概要
    
    my $five = 5;
    print "an interpolating string, just like in perl $five\n";
    say 'say() adds a newline to the output, just like in perl 5.10';

    my @array = 1, 2, 3, 'foo';
    my $sum = @array[0] + @array[1];
    if $sum > @array[2] {
        say "not executed";
    }
    my $number_of_elems = @array.elems;     # 或者使用 +@array
    my $last_item = @array[*-1];

    my %hash = foo => 1, bar => 2, baz => 3;
    say %hash{'bar'};                       # 2
    say %hash<bar>;                         # 同上, 会自动的加上双引 
    # 在这使用 %hash{bar} 是错误的
    # 没加引号的字符, 这会试着调用 bar 函数. 但这不存在 

### 描述

Perl 6 这些部分很象 Perl 5 - 只会变得更加友好. 声明的语句还是以分号终止. 在代码块中最后的语句和在行结束的右大括号的分号终止符是可选的.

变量仍然以记号 (象 `$`, `@`, `%`)开头.

#### 字符串 

字符串是用双引号包起来 ( 插值的情况下 ), 或者使用单引号. 反斜杠转义的工作方式和 Perl 5 中一样.

然而插值规则已经改变了一点. 看下面插值

    my $scalar = 6;
    my @array = 1, 2, 3;
    say "Perl $scalar";         # 'Perl 6'
    say "An @array[]";          # 'An 1 2 3', a so-called "Zen slice"
    say "@array[1]";            # '2'
    say "Code: { $scalar * 2 }" # 'Code: 12'

数组和哈希只有当后面跟索引的时候才会插值 ( 或者方法调用, 象 `"some $obj.method()"` ), 空索引会给整个数据结构做插值操作.

当出现了一个花括号时会执行花括号中的代码给结果进行插值操作.

#### 数组

数组还是以 `@` 标记开始. 并且他们总是这样 ( 在 Perl 5 中元素文章不是 @ 是 $  ), 就算访问数组中的元素也是使用 @ 开头. ie. 这个索引需要存在, 这个对新手学习就不在会晕了.

    my @a = 5, 1, 2;            # 不再需要括号 
    say @a[0];                  # 没错, 是以 @ 开头 
    say @a[0, 2];               # 数组切片也能正常工作 

列表的构造是通过逗号, 不在需要括号. `1,` 是一个列表, `(1)` 不是. 

既然一切都是对象，你可以调用数组的方法:

    my @b = @a.sort;
    @b.elems;                   # 成员元素数量 
    if @b > 2 { say "yes" }     # 仍然可以这样 
    @b.end;                     # 最后一个索引的位置, 替换 $#array
    my @c = @b.map({$_ * 2 });  # 没错, map 也是个方法调用 

下面的方法是替换老的 `qw/../` 来进行字符数组的构造:

    my @methods = <shift unshift push pop end delete sort map>;

#### 哈希 

Perl 6 在列表上下文时哈希是列表对. 列表对可以做一些其它的事情, 它可以是子函数的名字, 稍后详述.

就象数组使用的开头的标记不变, 哈希也是一样. 当你创建索引时使用 % 开头. 并且 hash 也有自己的方法调用.

    my %drinks =
        France  => 'Wine',
        Bavaria => 'Beer',
        USA     => 'Coke';

    say "The people in France love ",  %drinks{'France'};
    my @countries = %drinks.keys.sort;

注意, 当你访问哈希的元素是通过 `%hash{...}`, 这个 key 不会象 Perl 5 自动的加引号. 所以 `%hash{foo}` 并不能访问到索引 `"foo"` 的元素. 这会调用 `foo()` 的函数. 需要自动的对字符加引号就需要如下这种不同的语法:

    say %drinks<Bavaria>;

#### 最后的注意事项 

大多内置的方法, 既作为一种方法也可以做为 sub 调用. 所以你可以写在 `sort @array`  或者 `@array.sort`.

最后, 你需要知道这 `[..]` 和 `{...}' 这二个东西, 现在它们只是方法调用的特殊语法, 在这不是绑定数组和哈希. 这意味着, 他们也不会依赖于特定的前缀符号.

    my $a = [1, 2, 3];
    say $a[2];          # 3

这意味着, 我们不需要特殊的引用和解引用的语法, 并且您可以创建能够同时充当数组, 哈希和 sub 子函数的对象.

### 另请参阅

<http://perlcabal.org/syn/S02.html>, <http://perlcabal.org/syn/S29.html>

## Types

Sat Sep 20 22:40:00 2008

### [NAME][61]

"Perl 5 to 6" Lesson 02 - Types

### 概要

    my Int $x = 3;
    $x = "foo";         # error
    say $x.WHAT;        # 'Int()'

    # check for a type:
    if $x ~~ Int {
        say '$x contains an Int'
    }

### 描述[63]

Perl 6 有类型. 因为任何东西都是对象, 都有类型. 变量可以有类型的限制, 并他们并不是必需的.

有一些基本的类型, 你必须知道的:

    'a string'      # Str
    2               # Int
    3.14            # Rat (rational number)
    (1, 2, 3)       # Seq

全部 "标准" 的内置类型都是大写字母开头. 全部 "标准" 类型继承 "Any", 所有的类型都继承 `Mu`.

你可以限制变量在你的值的类型, 只要你在声明的时候指定变量类型.

    my Numeric $x = 3.4;
    my Int @a = 1, 2, 3;

有一种错误是, 试图给存一个错误的类型的值到一个变量 (ie neither the specified type nor a subtype).

类型的声明也合适于数组的包含的元素内容, 所以 `my Str @s` 是指定这个数组只能包含字符串.

有某些类型可以代表更加具体的类型, 象 integers (type `Int`), rationals (type `Rat`) 和 浮点数 (type `Num`) 这些都是 `Numeric` 类型.

#### [Introspection][64]

你可以通过调用 `.WHAT` 方法了解对象的详细类型.

    say "foo".WHAT;     # Str()

如果你想检查一些东西的类型, 有不同的方式, 也需要考虑到类型的继承, 所以建议使用下面的方法:

    if $x ~~ Int {
        say 'Variable $x contains an integer';
    }

### [MOTIVATION][65]

这个类型系统是不是很容易了解所有的细节. 为什么我们需要类型, 使用他们也有很多理由:

[Programming safety][66]

程序安全, 如果你声明了一些东西是特定的类型, 你就可以肯定的在上面执行某些操作, 并不需要检查它是什么.

[Optimizability][67]

当你在编译的时候有类型的信息, 可以执行更多的优化,  Perl 6 原则上不一定比 C 慢.

[Extensibility][68]

当有类型信息时, 使用 multiple dispatch 时更加容易细化特定的操作.

### 另请参阅[69]

[http://perlcabal.org/syn/S02.html#Built-In_Data_Types][70],

## Basic Control Structures

Sat Sep 20 23:00:00 2008

### [NAME][71]

"Perl 5 to 6" Lesson 03 - Basic Control Structures

### 概要[72]

    if $percent > 100  {
        say "weird mathematics";
    }
    for 1..3 {
        # using $_ as loop variable
        say 2 * $_;
    }
    for 1..3 -> $x {
        # with explicit loop variable
        say 2 * $x;
    }

    while $stuff.is_wrong {
        $stuff.try_to_make_right;
    }

    die "Access denied" unless $password eq "Secret";

### 描述[73]

大多数的 Perl 5 的控制结构和 Perl 6 是颇为相似，最大的视觉差异的是，你在使用 `if`, `while`, `for` 之类不后需要一对括号.

为什么, 当任何标识符后面紧跟着(无空格)一个左括号时很容易被解析成子程序调用. 所以  `if($x < 3)` 很容易变成调用 `if` 函数. 所以这样更加安全, 还不需要写括号.

#### [Branches][74]

`if` 功能大部分没在变化, 仍然可以添加  `elsif` 和 `else` 分支. `unless` 仍然存在，但是在 `unless` 之后没有了 `else` 分支.

    my $sheep = 42;
    if $sheep == 0 {
        say "How boring";
    } elsif $sheep == 1 {
        say "One lonely sheep";
    } else {
        say "A herd, how lovely!";
    }

你现在还是可以使用 `if` 和 `unless` 做语句修饰, 即后声明.

    say "you won" if $answer == 42;

#### [Loops][75]

你可以控制循环通过  `next` 和 `last` 就象 Perl 5 一样.

在这 `for` 循环现在只用于遍历列表. 默认是操作 `$_` 变量, 除非显式的指出变量名.

    for 1..10 -> $x {
        say $x;
    }

在这的 `-> $x { ... }`  是叫做  "pointy block" 这就象一个匿名的 sub or lisp 中的 lambda 操作.

你也可以使用一个以上的循环变量:

    for 0..5 -> $even, $odd {
        say "Even: $even \t Odd: $odd";
    }

这也是遍历哈希值的好方法:

    my %h = a => 1, b => 2, c => 3;
    for %h.kv -> $key, $value {
        say "$key: $value";
    }

这个 C-style 的 for 循环现在叫做 `loop` (这是唯一需要括号的循环结构):

    loop (my $x = 2; $x < 100; $x = $x**2) {
        say $x;
    }

### 另请参阅[76]

[http://perlcabal.org/syn/S04.html#Conditional_statements][77]

## Subroutines and Signatures

Sat Sep 20 23:20:00 2008

### [NAME][78]

"Perl 5 to 6" Lesson 04 - Subroutines and Signatures

### 概要[79]

    # sub without a signature - perl 5 like
    sub print\_arguments \{
        say "Arguments:";
        for @\_ \{
            say "\\t$\_";
        \}
    \}

    # Signature with fixed arity and type:
    sub distance(Int $x1, Int $y1, Int $x2, Int $y2) \{
        return sqrt ($x2-$x1)\*\*2 + ($y2-$y1)\*\*2;
    \}
    say distance(3, 5, 0, 1);

    # 默认参数 
    sub logarithm($num, $base = 2.7183) \{
        return log($num) / log($base)
    \}
    say logarithm(4);       # uses default second argument
    say logarithm(4, 2);    # explicit second argument

    # 命名参数

    sub doit(:$when, :$what) \{
        say "doing $what at $when";
    \}
    doit(what => 'stuff', when => 'once');  # 'doing stuff at once'
    doit(:when<noon>, :what('more stuff')); # 'doing more stuff at noon'
    # illegal: doit("stuff", "now")

### 描述[80]

子函数是使用  `sub` 关键字来声明, 并且有形式参数列表, 就象 C, Java 和一些其它的语言. 这些参数的类型约束是可选的.

参数默认是只读的. 可通过 "traits" 来改变.

    sub try-to-reset($bar) \{
        $bar = 2;       # 禁止修改参数
    \}

    my $x = 2;
    sub reset($bar is rw) \{
        $bar = 0;         # 可以修改
    \}
    reset($x); say $x;    # 0

    sub quox($bar is copy)\{
        $bar = 3;
    \}
    quox($x); say $x    # still 0

参数可以在后面增加一个问号来标记是否可选.

    sub foo($x, $y?) \{
        if $y.defined \{
            say "Second parameter was supplied and defined";
        \}
    \}

    sub bar($x, $y = 2 \* $x) \{
        ...
    \}

#### [Named Parameters][81]

当你调用子函数是这样的: `my_sub($first, $second)` 这个 `$first` 参数会绑定到第一个正式的参数, `$second` 会传递给第二个参数..等等, 这就是所谓的位置 "positional".

有时, 我们希望使用更加容易记住的名字, 而不是数字. 变是为什么使用命名参数:

    my $r = Rectangle.new(
            x       => 100,
            y       => 200,
            height => 23,
            width  => 42,
            color  => 'black'
    );

当你看到这样这些名字, 你马上知道参数具体是什么含义。

要定义一个命名参数, 你只需要给 `:` 放在参数之前: 

    sub area(:$width, :$height) {
        return $width * $height;
    }
    area(width => 2,  height => 3);
    area(height => 3, width => 2 ); # the same
    area(:height(3), :width(2));    # the same

The last example uses the so-called _colon pair syntax_. Leaving off the name results in the value being `True`, and negating it results in the value being `False`:

    :draw-perimeter                 # same as "draw-perimeter => True"
    :!transparent                   # same as "transparent => False"

在命名参数的声明, 变量名也被用来作为参数的名称. 您可以使用不同的名称:

    sub area(:width($w), :height($h)) {
        return $w * $h;
    }
    area(width => 2,  height => 3);

#### [Slurpy Parameters][82]

你给你的 sub 参数的时候, 有时你并不知道所有的参数个数. 你可以定义一种称作 _slurpy_ 参数来使用任何剩余个数的参数:

    sub tail ($first, *@rest){
        say "First: $first";
        say "Rest: @rest[]";
    }
    tail(1, 2, 3, 4);           # "First: 1\\nRest: 2 3 4\\n"

对于哈希, 命名的 slurpy 参数定义是使用前端有 * 号的哈希参数:

    sub order-meal($name, *%extras) {
        say "I'd like some $name, but with a few modifications:";
        say %extras.keys.join(', ');
    }

    order-meal('beef steak', :vegetarian, :well-done);

#### [Interpolation][83]

默认数组是不能插入到参数的列表中. 所以这不同于 Perl 5 的写法.

    sub a($scalar1, @list, $scalar2) {
        say $scalar2;
    }

    my @list = "foo", "bar";
    a(1, @list, 2);                  # 2

这也意味着, 默认的情况下你不能使用一个列表做为参数列表:

    my @indexes = 1, 4;
    say "abc".substr(@indexes)       # 不能实现你想做的 

(实际的情况是, 第一个参数需要是一个 `Int`, 并且被强制转换成 Int, 所以你可以写成 `"abc."substr(@indexes.elems)` 来放在第一位).

当然, 你也可以使用前缀 `|` 来完成所需的行为

    say "abcdefgh".substr(|@indexes) #  结果 bcde, 等同于 "abcdefgh".substr(1, 4)

#### [Multi Subs][84]

实际上, 你其实可以定义多个 sub 来使用相同的名字, 但接收不同的参数列表:

    multi sub my_substr($str) { ... }                          # 1
    multi sub my_substr($str, $start) { ... }                  # 2
    multi sub my_substr($str, $start, $end) { ... }            # 3
    multi sub my_substr($str, $start, $end, $subst) { ... }    # 4

现在, 当你调用这个 sub 时, 所述的参数会有一个匹配上并选择使用的.

这个 multis 并不只是可以工作在参数数量不等的情况上, 也可以工作在不同的参数类型的时候:

    multi sub frob(Str $s) { say "Frobbing String $s"  }
    multi sub frob(Int $i) { say "Frobbing Integer $i" }

    frob("x");      # Frobbing String x
    frob(2);        # Frobbing Integer 2

### [MOTIVATION][85]

没有人会怀疑明确的子函数参数的实用性: 少打字, 少重复的参数检查, 更多的安全文档代码. 

这些功能还有益于自省. 例如, 当传递给一个块或者子函数使用 `Array.sort`, 并且这段代码预期只有一个参数, 完成 Schwartzian 转换( 见 [http://en.wikipedia.org/wiki/Schwartzian_transform][86] ) 是自动的 - 这些功能在 Perl 5 中不太可能, 由于少了明确的参数, 意味着排序代码块永远不知道有多少个参数.

Multi subs 这个功能也非常有用, 因为它可以使用新类型来覆盖内建命令. 假设你想有一个版本的 Perl6 是本地化上来正确处理土耳其字符串，这对大小写转换是使用的不同寻常的规则时非常好用.

而不是修改语言本身. 你只需要加入一个新的 `TurkishStr`, 并为原生的函数加入一个 multi subs:

    multi uc(TurkishStr $s) { ... }

现在, 所有这个对字符串处理就会自动对应他们的语言类型, 然后你就可以使用 `uc` 函数象内置的函数一样.

由于操作也可以使用 subs, 所以这些改进操作是可以正常工作的.

### 另请参阅[87]

<http://perlcabal.org/syn/S06.html>

## Objects and Classes

Tue Sep 23 22:20:00 2008

### [NAME][88]

"Perl 5 to 6" Lesson 05 - 对象和类

### 概要[89]

    class Shape {
        method area { ... }    # literal '...'
        has $.colour is rw;
    }

    class Rectangle is Shape {
        has $.width;
        has $.height;

        method area {
            $!width * $!height;
        }
    }

    my $x = Rectangle.new(
            width   => 30.0,
            height  => 20.0,
            colour  => 'black',
        );
    say $x.area;                # 600
    say $x.colour;              # black
    $x.colour = 'blue';

### 描述[90]

Perl 6 比起 Perl 5 更加好的地方在于对象模型. 它有可以通过关键字创建类, 角色, 属性和方法, 并可以封装私有属性和方法. 事实上, 这个很象 Perl 5 中的 `Moose`( 这东西的灵感来自 Perl 6 的对象系统).

有两种方法来声明类

    class ClassName;
    # 类定义放在这里 

第一个是文件一开始就有一个 `class ClassName;` 并一直延伸到文件的末尾. 第二种方法是类名后跟一个块, 块中所有的都被认为是当前类的定义.

    class YourClass {
        # 类定义放在这里 
    }
    # 更多的类和其它的代码

#### [Methods][91]

方法定义是使用 `method` 关键字. 在方法内部可以使用 `self` 来指向对象本身.
Methods are declared with the `method` keyword. Inside the method you can use the term `self` to refer to the object on which the method is called (the _invocant_).

你也可以通过参数来给调用者一个不同的名字. 并附加一个冒号 `:` 来给它.

Public 的公有方法可以通过语法 `$object.method` 来调用, 有参数的话,可以使用 `$object.method(@args)` 或者 `$object.method: @args`  来调用.

    class SomeClass {
        # these two methods do nothing but return the invocant
        method foo {
            return self;
        }
        method bar(SomeClass $s: ) {
            return $s;
        }
    }
    my SomeClass $x .= new;
    $x.foo.bar                      # same as $x

(这个 `my SomeClass $x .= new` 其实是 `my SomeClass $x = SomeClass.new` 的简写. 这之所以正常工作是因为, 这是一个类型声明, 声明这个变量的类型是一个 `SomeClass` 的 "typo object", 这个类型对象就表示类的对象)

方法可以象子函数一样接收参数.

Private 的私有方法可以通过 `method !methodname` 的方式来声明, 调用通过  `self!method_name`.

    class Foo {
        method !private($frob) {
            return "Frobbed $frob";
        }

        method public {
            say self!private("foo");
        }
    }

私有的方法并不能从类的外面调用.

#### [Attributes][92]

属性声明通过 `has` 关键字, 有个 "twigil" 的功能, 这是在特别符号之后有些特定的字符串. 对于私有属性, 这是一个 `!`, 对于公有属性, 这是使用 `.`. 
公共属性实际上是有公有的访问权限的私有属性. 所以, 它不能修改, 如果你想修改时, 就需要使用 `!` 来访问实际的属性而不是使用存取器(除非它被标记为 `is rw`).

    class SomeClass {
        has $!a;
        has $.b;
        has $.c is rw;

        method set_stuff {
            $!a = 1;    # ok, writing to attribute from within the clas
            $!b = 2;    # same
            $.b = 3;    # ERROR, can't write to ro-accessor
        }

        method do_stuff {
            # you can use the private name instead of the public one
            # $!b and $.b are really the same thing
            return $!a + $!b + $!c;
        }
    }
    my $x = SomeClass.new;
    say $x.a;       # ERROR!
    say $x.b;       # ok
    $x.b = 2;       # ERROR!
    $x.c = 3;       # ok

#### [Inheritance][93]

继承是通过 `is` 这个关键字.

    class Foo is Bar {
        # 类 Foo  继承类 Bar
        ...
    }

所有常用的继承规则 - 方法会先直接检查自己的类型, 如果失败, 操作父类（递归）.同样的, 一个子类的类型是否符合父类:

        class Bar { }
        class Foo is Bar { }
        my Bar $x = Foo.new();   # ok, since Foo ~~ Bar

在这个例子中 `$x` 的类型是 `Bar`, 它允许分配一个对象类型 `Foo` 给它, 因为每天个 "`Foo` 都是 `Bar` 之下".

类也可以继承多个其它的类:

    class ArrayHash is Hash is Array {
        ...
    }

尽管多重继承会附加很多问题, 人们通常会建议反对这么使用. 角色往往是一个更安全的选择.

#### [Roles and Composition][94]

现实的世界是不分层, 所以有时很难给一切都使用层次结构继承. 这也是为什么 Perl 6 中有角色的原因之一. 角色和类十分类似, 除了你不能由角色直接创建对象, 也不能使用相同的名字组成. 
In general the world isn't hierarchical, and thus sometimes it's hard to press everything into an inheritance hierarchy. Which is one of the reasons why Perl 6 has Roles. Roles are quite similar to classes, except you can't create objects directly from them, and that composition of multiple roles with the same method names generate conflicts, instead of silently resolving to one of them, like multiple inheritance does.

虽然类主要针对的是类型一致性, 但角色才是在 Perl6 的代码重用的主要手段。

    role Paintable {
        has $.colour is rw;
        method paint { ... }
    }
    class Shape {
        method area { ... }
    }

    class Rectangle is Shape does Paintable {
        has $.width;
        has $.height;
        method area {
            $!width * $!height;
        }
        method paint() {
            for 1..$.height {
                say 'x' x $.width;
            }
        }
    }

    Rectangle.new(width => 8, height => 3).paint;

### 另请参阅[95]

<http://perlcabal.org/syn/S12.html> <http://perlcabal.org/syn/S14.html> <http://www.jnthn.net/papers/2009-yapc-eu-roles-slides.pdf> [http://en.wikipedia.org/wiki/Perl\_6#Roles][96]

## Contexts

Wed Sep 24 22:20:00 2008

### [NAME][97]

"Perl 5 to 6" Lesson 06 - Contexts 上下文

### 概要[98]

    my @a = <a b c>;
    my $x = @a;
    say $x[2];          # c
    say (~2).WHAT;      # (Str)
    say +@a;            # 3
    if @a < 10 { say "short array"; }

### 描述[99]

当你写了一些如下的东西

    $x = @a

在 Perl 5 中 `$x` 包含的信息会比 `@a` 少 - 它包含只有  `@a` 中元素的个数. 要保存所有的信息, 你只能明确的指出它是一个引用: `$x = \@a`.

在 Perl 6 中是反过来的: 默认你不会丢失任何东西, 标量会存储整个数组. 之所以能这样,  是因为有一个 item 的通用上下文( 在 Perl 5 中叫 _scalar_ )和其它更加专业的象数字, 整型, 和字符上下文. 空和列表上下文保持不变.

你可以强制上下文环境, 通过下面的语法

    语法         上下文

    ~stuff       String
    ?stuff       Bool (logical)
    +stuff       Numeric
    -stuff       Numeric (also negates)
    $( stuff )   Generic item context
    @( stuff )   List context
    %( stuff )   Hash context
     stuff.tree  Tree context

#### [Tree Context][100]

在Perl6的初期, 还有二个版本的原生内建, 一个返回简单列表, 一个返回数组列表(象是数组的数组).

现在是通过返回列表内部内容的对象, 通过返回的东西可能会和可能不会拉平这依赖于上下文.

考虑中缀操作 `Z` (它是 _aip_ 操作的简写)操作符, 交错从二个列表中取元素:

    my @a = <a b c> Z <1 2 3>;
    say @a.join;                # a1b2c3

这发生的事情是, 第一个语句的右边返回 `('a', 1), ('b', 2), ('c', 3)`, 并赋值给一个数组, 它提供列表上下文, 然后接下操作会拉平内部的元素.

其它可能发现的情况

    my @t = (<a b c> Z <1 2 3>).tree;

这个 `@t` 现在包含三个元素, 每个数组都没有拉平.

    for @t -> @inner {
        say "first: @inner[0]  second: @inner[1]"
    }

会输出:

    first: a  second: 1
    first: b  second: 2
    first: c  second: 3

### [MOTIVATION][101]

更具体的上下文中是一种方法以延迟的设计选择. 例如. 我们要决定在标题上下文时要返回什么清单- 引用的列表需要保留所有的信息, 但在数字比较时没用. 另外,字符串表示形式也对于调试目的更别有用. 但每种选择总是会有人失望的.

大多的时候, 你根本不要做这样的选择 - 它都会返回合理的值. 不需要你选择怎么样返回.

对于一些事情, 象 Match 对象, 这种不同的上下文提升了实用性和美感.

### 另请参阅[102]

<http://perlcabal.org/syn/S02.html#Context> <http://perlgeek.de/blog-en/perl-6/immutable-sigils-and-context.html>

## Regexes (also called "rules")

Thu Sep 25 22:20:00 2008

### [NAME][103]

"Perl 5 to 6" Lesson 07 - Regexes 正则表达式 (also called "rules")

### 概要[104]

    grammar URL {
        token TOP {
            <schema> '://'
            [<ip> | <hostname> ]
            [ ':' <port>]?
            '/' <path>?
        }
        token byte {
            (\d**1..3) <? $0 < 256 \}>
        }
        token ip {
            <byte> [\. <byte> ] ** 3
        }
        token schema {
            \w+
        }
        token hostname {
            (\w+) ( \. \w+ )\*
        }
        token port {
            \d+
        }
        token path {
            <[ a..z A..Z 0..9 \-_.!~\*'():@&amp;=+$,/ ]>+
        }
    }

    my $match = URL.parse('http://perl6.org/documentation/');
    say $match<hostname>;       # perl6.org

### 描述[105]

正则表达式已经大量改良和革新, 是 Perl 6 改进之一. 我们不叫它 _regular expressions_ 了. 因为它比起 Perl 5 更加不正规.

正则表达式有三个大的更改和改进

[Syntax clean up][106]

许多小变化使得规则更加容易编写. 例如, dot `.` 在匹配任何字符. 旧的语义是除了换行, 现在你可以使用 `\N` 来实现匹配零个或者多个非换行符.

修饰符现在是放在正则表达式的起始位置, 并且修改了非捕获组变成是 `[...]`, 这比起旧的 `(?:...)` 更加容易读取和写.

[Nested captures and match object][107]

在 Perl 5 中, 正则 `(a(b))(c)` 会给 `ab` 存到 `$1`, `b` 会存到 `$2` 和 `c` 存到 `$3`. 这种情况现在改变, 现在 `$0` (枚举从零开始)包含 `ab`, `$0[0]` or `$/[0][0]` 包含 `b`, `$1` 存着 `c`. 所以括号中的每个嵌套级别反映在结果匹配对象的一个新的嵌套级别.

所有匹配变量是别名为 `$/`，也就是所谓的 _Match object_, 它实际上是一个包含了完整的匹配树型结构的对象。

[Named regexes and grammars][108]

你可以定义你正则表达式的名字, 就象在 subs 和方法中. 你可以通过 `<name>` 来在其它地方使用这个. 你可以给多个正则表达式做成 grammars, 这就象类和支持继承和组合.

这些改变使得 Perl 6 的正则表达式和 grammars 比起 Perl 5 更加容易维护和编写.

这些变化的东西比较深, 这个文章中, 我们只能见到表面的东西.

#### [Syntax clean up][109]

字母字符 ( 如下划线, 数字和所有 Unicode 字母) 匹配从字面上看, 当使用反斜杠转义时具有特殊的意义( 这是 _metasyntactic_ ), 对于所有的其它字符是反过来的 - 除非它转义.

    literal         metasyntactic
    a  b  1  2      \a \b \1 \2
    \* \: \. \?     *  :  .  ? 

Not all metasyntactic tokens have a meaning (yet). It is illegal to use those without a defined meaning.

在正则表达式中还有另一种方法来转义字符串: 通过引号.

    m/'a literal text: $#@!!'/

这改变了 `.` 的语义, 这提到过， 同时又有 `[...]` 现在构建非捕获组. 字符类是　`<[...]>`　和非字符类`<-[...]>`。　`^`　和　`$`　总是匹配开始和结束的字符串。　匹配行的开始和结束是使用　`^^`　和　`$$`.

这意味着`/ s的`和`/ M`修饰都没有了. 修饰符现在是在正则表达式的开始给出:

    if "abc" ~~ m:i/B/ {
        say "Match";
    }

... 这又是使用的　_colon pair_　符号。　你可以使用这个象命名参数和子函数一样.


修饰符有一个短的和长的形式. 现在老 `/x` 修饰符是默认的, 即空格会被忽略.

    short   long            meaning
    -------------------------------
    :i      :ignorecase     ignore case (formerly /i)
    :m      :ignoremark     ignore marks (accents, diaeresis etc.)
    :g      :global         match as often as possible (/g)
    :s      :sigspace       Every white space in the regex matches 正则表达式匹配所有空格
                            (optional) white space
    :P5     :Perl5          Fall back to Perl 5 compatible regex syntax
    :4x     :x(4)           Match four times (works for other numbers as well)
    :3rd    :nth(3)         Third match
    :ov     :overlap        Like :g, but also consider overlapping matches
    :ex     :exhaustive     Match in all possible ways
            :ratchet        Don't backtrack

这的　`:sigspace` 需要更多的解释. 它通过　`<.ws>`　替换了模式中的空格　 (that is it calls the rule `ws` without keeping its result).　你可以覆盖该规则.

默认会匹配单词字符前后所包含的一个或者多个空格.

By default it matches one or more whitespaces if it's enclosed in word characters, and zero or more otherwise.

#### [The Match Object][110]

每个 match 会生成一个叫　match object　的东西, 会给这些存储到指定的变量　`$/`　中.　它是非常有用的. 如果匹配成功在布尔上下文中，返回 `Bool::True`. 在字符上下文会返回匹配到的字符,　作为一个列表时使用其中包含的位置捕获, 作为哈希使用时它包含命名捕获. 这　`.from`　和　`.to`　方法包含首先的和最后的字符位置上找到的内容.

    if 'abcdefg' ~~ m/(.(.)) (e | bla ) $<foo> = (.) / {
        say $/[0][0];           # d
        say $/[0];              # cd
        say $/[1];              # e
        say $/<foo>             # f
    }

这的　`$0`, `$1` 　只是　$/[0]`, `$/[1]`　的别名. 同样　`$/<x>`　和　`$/{'x'}`　也只是　`$<x>`　的别名.

注意, 任何你通过　`$/[...]`　和　`$/{...}`　访问的都是　match 对象( 或者是　match 对象的列表). 这可以让你通过规则创建真实的解析树。

#### [Named Regexes and Grammars][111]

正则表达式可以是与旧的风格 `m/.../`, 或者声明象子函数和方法.

    regex a { ... }
    token b { ... }
    rule  c { ... }

所不同的是 `token` 隐含了 `:ratchet` 修饰符(这意味着没有回溯, 象　`(?> ... )` 组包含各自的部分)，　这个　`rule`　含了　`:ratchet`　和　`:sigspace`.

要调用这些规则 (我们会要调用的这些规则, 通过关键字声明后相互独立) 使用尖括号中的名称: `<a>`. 这隐含地锚定子规则的字符串中的当前位置, 存储结果到`$/<a>`　的对象中, 也就是说, 它是一个命名捕获. 你也可以调用规则通过点的前缀操作　`<.a>`　来调用.

grammar 是一系列规则的组, 这很象类 ( 看　SYNOPSIS　中的例子). Grammars 可以继承，重写规则等.

    grammar URL::HTTP is URL {
        token schema { 'http' }
    }

### [MOTIVATION][112]

Perl 5 的正则表达式常常不太可读, grammars 鼓励你把一个大的正则表达式表示成为更可读的, 短的片段. 命名捕获使规则更加能实现自我文档, 而且很多东西比起以前现在更加一致.

最后, grammars 是如此强大, 你可以用它分析了解每一种编程语言, 包括 Perl6 本身. 这使得 Perl 6 的语法比起 Perl 5 更易于维护和修改比Perl 5.

### 另请参阅[113]

<http://perlcabal.org/syn/S05.html>

<http://perlgeek.de/en/article/mutable-grammar-for-perl-6>

<http://perlgeek.de/en/article/longest-token-matching>

## Junctions

Fri Sep 26 22:20:00 2008

### [NAME][114]

"Perl 5 to 6" Lesson 07 - Junctions

### 概要[115]

    my $x = 4;
    if $x == 3|4 {
        say '$x is either 3 or 4'
    }
    say ((2|3|4)+7).perl        # (9|10|11)

### 描述[116]

Junctions 是叠加的一堆无序的值. 操作 junctions 的时候是对各自己的元素分别进行　junction (甚至是并行的), 并且结果组装成相同类型.

在　junction　类型唯一的不同点在于计算布尔上下文时. 这类型有　`any`, `all`, `one` and `none`.

    Type    Infix operator
    any     |
    one     ^
    all     &

`1 | 2 | 3` 等同于 `any(1..3)`.

    my Junction $weekday = any <Monday Tuesday Wednesday
                                Thursday Friday Saturday Sunday>
    if $day eq $weekday {
        say "See you on $day";
    }

在这个例子中　`eq` 的这个操作的会调用每个元素象　`$day, 'Monday'`, `$day, 'Tuesday'`　等等. 并将结果放入 `any`-junction 中来. 只要结果被确认了(在这个例子中, 只要有任意一个比较返回'真')　它可以会中止其他比较的执行.

这不但对操作符有效, 对子函数也行:

    if 2 == sqrt(4 | 9 | 16) {
        say "YaY";
    }

为了做到这一点, junctions 是放在了正常的类型层次结构之外的:

                      Mu
                    /    \\
                   /      \\
                 Any     Junction
               /  |  \\
            All other types


如果你想写一个函数使用这个 junction 并且不　autothread　这个子函数, 你可以声明这些的参数是　`Mu`　或者是 `Junction`

    sub dump_yaml(Junction $stuff) \{
        # we hope that YAML can represent junctions ;-)
        ....
    }

提醒一句: Junctions 有时的表现会和你的直觉相反. 如果是非 junction 类型的时候 `$a != $b` 和 `!($a == $b)` 总是相同的结果. 如果这些变量中有一个是 junction 类型时, 这个结果就不一样了.

    my Junction $b = 3 | 2;
    my $a = 2;
    say "Yes" if   $a != $b ;       # Yes
    say "Yes" if !($a == $b);       # no output

`2 != 3` 是为真, 这 `$a != 2|3` 也是为真. 在其它的时候象 `$a == $b` 比较会返回布尔值 (`True`), 然后在取反为 `False`.

### [MOTIVATION][117]

Perl 的目标是要接近自然语言, 自然语言中你常常会这样讲 "这如这个结果这样或者那样" 而不会讲 "如果这个结果是这样或者这个结果是那样". 很多编程语言都只能使用后者, 感觉有点奇怪. 所以还是 Perl 6 比较好.

这个东西也让你容易多了, 不然要使用循环写很多比较.

例如, 有个数组都是数字的, 你想知道如果全部的是不是都是非负数, 在 Perl 5 中, 你可能会写成下面这样:

    # Perl 5 code:
    my @items = get_data();
    my $all_non_neg = 1;
    for (@items){
        if ($_ < 0) {
            $all_non_neg = 0;
            last;
        }
    }
    if ($all_non_neg) { ... }

如果你知道 Perl  5 中的这个模块, `List::MoreUtils` 你可能会写成:

    use List::MoreUtils qw(all);
    my @items = get_data;
    if (all { $_ >= 0 } @items) { ...  }

在 Perl 6 中你只需要写成:

    my @items = get_data();
    if all(@items) >= 0 { ... }

### [A Word of Warning][118]

很多人知道这个 junctions 非常高兴, 都会大量尝试使用这个.

但要知道 Junctions 并不是一个 sets(集合); 所以你没法从 junction 中提取元素, 你这样做就错了, 所以你想要这样就要使用 `Set` 替代.

It is a good idea to use junctions as smart conditions, but trying to build a solver for equations based on the junction autothreading rules is on over-extortion and usually results in frustration.

### 另请参阅[119]

[http://perlcabal.org/syn/S03.html#Junctive_operators][120]

## Comparing and Matching

Sat Sep 27 22:20:00 2008

### [NAME][121]

"Perl 5 to 6" Lesson 09 - Comparing and Matching 比较和匹配

### 概要[122]

    "ab"    eq      "ab"    True
    "1.0"   eq      "1"     False
    "a"     ==      "b"     failure, because "a" isn't numeric
    "1"     ==      1.0     True
    1       ===     1       True
    [1, 2]  ===     [1, 2]  False
    $x = [1, 2];
    $x      ===     $x      True
    $x      eqv     $x      True
    [1, 2]  eqv     [1, 2]  True
    1.0     eqv     1       False

    'abc'   ~~      m/a/    Match object, True in boolean context
    'abc'   ~~      Str     True
    'abc'   ~~      Int     False
    Str     ~~      Any     True
    Str     ~~      Num     False
    1       ~~      0..4    True
    -3      ~~      0..4    False

### 描述[123]

Perl 6 仍有字符串比较操作符 (`eq`, `lt`, `gt`, `le`, `ge`, `ne`; `cmp` 现在叫 `leg`) 用于评估字符串上下文件的操作. 同样 Perl 5 中的所有数值运算符还是存在.

由于对象是 blessed 的引用, 需要新的方式来进行比较 `===` 只有当值都相同的时候才返回真. 对于数字和字符串是正常的相等性测试, 其它的东西都是比较二个变量是否引用同一个东西( 象 C++ 中的内存地址比较 );

`eqv` 的测试是比较二个东西是不是等价的, 如果它们有相同的类型并也有相同的值. 在容器类型象数组和哈希, 使用 `eqv` 来进行比较. 二个结构相同的数组结构是不是等价.

#### [Smart matching][124]

perl 6 有一个通用比较符, 叫 "智能匹配" 操作符, 拼写成 `~~`. 它是不对称对比的, 一般右边的操作数的类型决定使用哪种比较.

对于数字和字符串是进行简单的相等性比较.  智能匹配对于类型对象是检查类型是否一致. 智能匹配对一个正则表达式是检查是否匹配正则. 如果一个标量来对比一个 `Range` 对象是会检查这个是否在这个范围内能查找到.

还有其它更加高级的匹配形式: 比如你可以检查一个参数列表 (`Capture`) 非常合适子函数参数或者文件测试操作.

你只需要记住, 任何 "这个 $x 是否合适 $y?" 这种问题都可以使用 Perl 6 的智能匹配.

### 另请参阅[125]

[http://perlcabal.org/syn/S03.html#Smart\_matching][126]

## Containers and Values

Wed Oct 15 22:00:00 2008

### [NAME][127]

"Perl 5 to 6" Lesson 10 - Containers and Values 容器和值

### [Synopsis][128]

    my ($x, $y);
    $x := $y;
    $y = 4;
    say $x;             # 4
    if $x =:= $y {
        say '$x and $y are different names for the same thing'
    }

### 描述[129]

Perl 6 区分不同的容器和值能存到各自的容器中.

标量变量是一个容器, 并能有像类型的限制, 访问限制（例如, 它可以是只读的）之类的一些属性，最后它可以被关联到其他容器.

放入一个值到容器, 叫做分配 _assignment_, 和两个容器做别名被称为 '绑定'.

    my @a = 1, 2, 3;
    my Int $x = 4;
    @a[0] := $x;     # 现在 @a[0] 和 $x 是相同的值 
    @a[0] = 'Foo';   # 错误 'Type check failed'

类型 `Int` 和 `Str` 是不能改变的, 所以这些对象不能被改变, 但你可以修改这些东西的值(在容器中的值):

    my $a = 1;
    $a = 2;     # no surprise here

绑定也可以在编译的时候就完成, 我们需要使用 `::=` 操作符.

你可以通过 `=:=` 的操作符来比较二个绑定在一起的东西.

### [MOTIVATION][130]

在子函数中的 Exporting 导出和 importing 导入, 这个类型和值都是通过别名. 用于替代 Perl 5 中难以理解的 typeglob 的语法, Perl 6 提供的这个简单多了.

### 另请参阅[131]

[http://perlcabal.org/syn/S03.html#Item_assignment_precedence][132]

## Changes to Perl 5 Operators

Thu Oct 16 22:00:00 2008

### [NAME][133]

"Perl 5 to 6" Lesson 11 - Changes to Perl 5 Operators 进化了以后的 Perl 5 中的操作符

### 概要[134]

    # 位运算符 
    5   +| 3;       # 7
    5   +^ 3;       # 6
    5   +& 3;       # 1
    "b" ~| "d";     # 'f'
 
    # 字符串连接 
    'a' ~ 'b';      # 'ab'

    # 文件测试
    if '/etc/passwd'.path ~~ :e { say "exists" }

    # 重复 
    'a' x 3;        # 'aaa'
    'a' xx 3;       # 'a', 'a', 'a'

    # 三元, 条件运算 
    my ($a, $b) = 2, 2;
    say $a == $b ?? 2 * $a !! $b - $a;

    # chained comparisons
    my $angle = 1.41;
    if 0 <= $angle < 2 * pi { ... }

### 描述[135]

所有的数值运算符 (`+`, `-`, `/`, `*`, `**`, `%`) 保持不变.

由于 `|`, `^` 和 `&` 现在 junctions 在使用, 所以位算符改变了语法. 它们现在包含一个上下文前缀, 所以象 `+|` 是逐位的运算基于数字上下文. `~^` 是对字符串上下文的异或. 位移操作也有相同的上下文前缀. 

字符串连接现在是使用的 `~`, 因为 `.` 现在被用于方法调用了.

文件测试, 现在是使用 `Pair(字符:功能)` 符号, 在 Perl 5 中的 `-e`  现在是 `:e`. 如果你不是想对 `$_` 进行检查操作, 你可以使用  `$filename.path ~~ :e` 的方式来指定路径.

这个重复操作 `x` 现在分开成二个操作符: `x` 是重复字符串, `xx` 是重复的列表.

三元运算符, 原来的 `$condition ? $true : $false`, 现在需要写成 `$condition ?? $true !! $false`.

比较操作符现在可以做成一串的链, 所以你可以根据你的意思, 写成象 `$a < $b < $c`.

### [MOTIVATION][136]

这些操作符的改变, 主要是为了写出更加好读好看的代码, 比如给最常使用的东西使用比较短的名字( 比如 `.` 现在用于方法调用 ) 和对于比较少使用的操作使用比较长的名字 ( 比如 `~&` 对于子符串进行位操作 );

比较操作之类都是为了使语言更加象自然语言一样. 

### 另请参阅[137]

[http://perlcabal.org/syn/S03.html#Changes_to_Perl_5_operators][138]

## Laziness

Fri Oct 17 22:00:00 2008

### [NAME][139]

"Perl 5 to 6" Lesson 12 - Laziness

### 概要[140]

    my @integers = 0..*;
    for @integers -> $i {
        say $i;
        last if $i % 17 == 0;
    }

    my @even := map { 2 * $_ }, 0..*;
    my @stuff := gather {
        for 0 .. Inf {
            take 2 ** $_;
        }
    }

### 描述[141]

对于象列表之类, 在 Perl 6 中都是 lazy 的.

之所以叫 _lazy_ 意味着, 这个东西的生成都是尽可能延迟. 当你写象 `@a := map BLOCK, @b`, 这个块并不执行. 当有当你从 `@a` 中访问这个东西的时候, 这个 `map` 函数才开始根据需要一个个执行和填充所需要的数据.

注意这个地方, 是使用的绑定操作符(:=), 而不是分配: 如果直接声明分配的函数会立即创建内容 ( 除非编译器知道这个列表是无限长的, 才不会生成 ), 而使用绑定并不会立即生成内容.

Laziness 的特性可以让你处理无限长度的列表: 他们所占的空间就和你操作这个列表的长度一样大. 所以你没一个个操作完元素, 这些并不会生成.

但这存在一些缺陷, 比如列表的排序会失去 Laziness 的特性. 如果这个列表是无限的, 有可能容易出现无限循环.

在正常的情况下, 如果转换成标量 ( 象 `List.join` ) 也会不使用 Laziness 的特性. 

Laziness 的特性可以防止不必要的计算, 所以可以提升性能, 同时保持代码的简单.

当你在 Perl 5 中一行行读文件时, 你之所以不使用 `for (<HANDLE>)` 是因为会读所有的文件到内存中, 然后才开始迭代, laziness 在这处理是不同的:

    my $file = open '/etc/passwd';
    for $file.lines -> $line {
        say $line;
    }

由于 `$file.lines`  在 Perl 6 中本身就是 lazy list, 所以只有物理读到文件时, 才会取到内存中来(当然除了 buffer 的需要外).

#### [gather/take][142]

创建 lazy lists 一个非常有用的方式是使用 `gather { take }`. 它象下面这样使用:

    my @list := gather {
        while True {
            # some computations;
            take $result;
        }
    }

这个 `gather BLOCK` 返回一个 lazy list. 只有当有操作必须使用 `@list` 中的元素时, 这个代码块才会运行直 `take` 块执行. 这个 `take` 就象 return 函数. 全部的 `take` 的返回的内容会构建 `@list`. 当需要更加的`@list` 块的元素时, 又会接着从上次的 `take` 之后执行这个代码块.

`gather/take` 是动态的范围, 所以它可以调用 `take` 在 `gather` 块的词法范围之外.

    my @list = gather {
        for 1..10 {
            do_some_computation($_);
        }
    }

    sub do_some_computation($x) {
        take $x * ($x + 1);
    }

注意这个 `gather` 也可以是单个语句声明, 而不是一个块:

    my @list = gather for 1..10 {
        do_some_computation($_);
    }

#### [Controlling Laziness][143]

Laziness 特性有可能会产生其它副作用 ( 当你尝试和学习过 Haskell 时, 你会发现它们中的 IO 系统是如此的奇怪. 因为他们是使用的 lazy 特性并且没什么副作用), 当你不想使用这个特性的时候, 可以在前面加个 `eager` 的关键字.

    my @list = eager map { $block_with_side_effects }, @list;

默认的情况下, lazy 只在列表的时候生效. 但你也可以让 lazy 工作在标量上:

    my $ls = lazy { $expansive_computation };

### [MOTIVATION][144]


在计算机科学中, 大多数的问题都可以通过定义树来解决, 很常用的一个解决方案是进行高效的算法和有效的搜索, 并且, 构建树其实也是非常有趣的部分.

通过 lazy 的列表, 你可以递归定义这个树并且查找它, 这个会特性会自动构造只有你实际使用过的部分.

在一般的情况下, laziness 特性可以让你写程序更加容易, 因为这是透明的. 就算计算的所有结果都会被使用到, 你也不会失去什么. 如果他不使用, 就根本也不会执行.

### 另请参阅[145]

<http://perlcabal.org/syn/S02.html#Lists>

## Custom Operators

Sat Oct 18 22:00:00 2008

### [NAME][146]

"Perl 5 to 6" Lesson 13 - Custom Operators 定制操作符

### 概要[147]

    multi sub postfix:<!>(Int $x) {
        my $factorial = 1;
        $factorial *= $_ for 2..$x;
        return $factorial;
    }

    say 5!;                     # 120

### 描述[148]

操作符其实是一个特别的名字的函数, 并且有一些额外的属性, 象优先级和结合性. 在 Perl 6 中通常的操作符的模式是 `term infix term(词语 中缀 词语)`, 词语能选择是前面使用前缀运算符,还是使用后缀或者 postcircumfix 操作符.

    1 + 1               infix
    +1                  prefix
    $x++                postfix
    <a b c>             circumfix
    @a[1]               postcircumfix

操作符的名字并不限制使用特定的字符, 你可以包含使用任何东西, 除了空白.

运算符的长的名字是它的类型, 后面跟着一个冒号和一个字符串文字或符号或符号的列表, 例如 `infix:<+>` 是 `1+2` 的运算. 其它的例子是 `postcircumfix:<[ ]>` 操作, 它是对 `@a[0]` 的操作.

当你知道这些知识, 你现在可以重新定义新运算符:

    multi sub prefix:<€> (Str $x) {
        2 *  $x;
    }
    say €4;                         # 8

#### [优先级]

中缀表达式象 `$a + $b * $c`, 这中间的 `infix:<*>` 操作符优先级比 `infix:<+>` 高, 这也就是为什么可以计算 `$a + ($b * $c)`.

新运算符的优先级可以通过下面的方式来指定:

    multi sub infix:<foo> is equiv(&infix:<+>) { ...  }
    mutli sub infix:<bar> is tighter(&infix:<+>) { ... }
    mutli sub infix:<baz> is looser(&infix:<+>) { ... }

#### [结合性]

很多的中缀操作符只有二个参数. 象执行 `1 / 2 / 4` 中的操作符的结合性是根据结合性顺序来的. 这个 `infix:</>` 操作符是左结合性, 所以执行的解析是 `(1 / 2) / 4` 的顺序来的. 如果是右结合性操作符, 象 `infix:<**>` 在执行 `2 ** 2 ** 4` 时执行的解析顺序是 `2 ** (2 ** 4)`.

Perl 6 中有着更加丰富的结合性: 如 `none` 是禁止优先级相同的操作符进行链接操作 (例如 `2 <=> 3 <=> 4`  是被禁止的 ), `infix:<,>` 是 `list` 结合性, 这个 `1, 2, 3` 会被转换成 `infix:<,>(1; 2; 3)`. 还有 `chain`  的结合性: `$a < $b < $c` 会被转换成 `($a < $b) && ($b < $c)`.

    multi sub infix:<foo> is tighter(&infix:<+>)
                          is assoc('left')
                          ($a, $b) {
        ...
    }

#### [Postcircumfix 和 Circumfix]

Postcircumfix 操作符是方法调用:

    class OrderedHash is Hash {
        method postcircumfix:<{ }>(Str $key) {
            ...
        }
    }

如果你调用 `$object{$stuff}`, 这个 `$stuff` 会当成参数传给方法调用, 这个 `$object` 是一个可用的 `self`.

Circumfix 的调用意味着这有不同的语法  ( 象 `my @list = <a b c>;` ), 是用于实现宏 (macros):

    macro circumfix:«< >»($text) is parsed / <-[>]>+ / {
        return $text.comb(rx/\S+/);
    }

这的 `is parsed` 特性后面跟一个正则表达式解析分隔符之间的所有东西.  If no such rule is given, it is parsed as normal Perl 6 code (which is usually not what you want if you introduce a new syntax). 

`Str.comb` 的给一个正则表达式, 并返回所有匹配的文本列表.

#### ["重载" 现有的操作符]

很多 (不是全部) 现有的操作符是使用的 multi subs 和方法调用, 所以可以定制新的类型. 添加一个新的 multi sub 就能实现重载操作符了.

    class MyStr { ... }
    multi sub infix:<~>(MyStr $this, Str $other) { ... }

这也意味着你可以重写看起来是内置对象的特殊对象, 比如  `Str`, `Int` etc.

### [MOTIVATION][153]

允许用户声明新的操作符和 "重载" 现有的用户定义的类型这非常强大. 如果内置的不合适你使用, 你可以使用自己的新的操作符, 无需编译器本身做任何改变.

它也消除使用语言和修改语言之间的差距.

### 另请参阅

[http://perlcabal.org/syn/S06.html#Operator_overloading][155]

如果你有兴趣了解相关的技术背景, 即 Perl 6 怎么实现这些操作符和其它 grammer 的改变, 你可以读读 <http://perlgeek.de/en/article/mutable-grammar-for-perl-6>.

## The MAIN sub

Sun Oct 19 22:00:00 2008

### [NAME][156]

"Perl 5 to 6" Lesson 14 - The MAIN sub

### 概要[157]

  # file doit.pl

  #!/usr/bin/perl6
  sub MAIN($path, :$force, :$recursive, :$home = '~/') {
      # do stuff here
  }

  # command line
  $ ./doit.pl --force --home=/home/someoneelse file_to_process

### 描述[158]

调用子函数和运行一个类 Unix 的命令行程序从视觉上看, 其实非常相似: 你可以有选项, 可选参数和命名参数.

使用 Perl 6 你可以从中利益很多, 它可以直接处理你的命令行, 并变成一个子函数调用. 你只要你的文件中存在  `MAIN` 的子函数, 你的脚本就可以正常的执行 ( 此时会给你的参数送给 `@*ARGS` ). 

如果你提交的参数在那个 `MAIN` 的函数中并不对应, 会自动的帮你生成 usage 的信息.

命令行的参数映射到子程序的参数是这样工作的:

  -name                   :name
  -name=value             :name<value>

  # remember, <...> is like qw(...)
  --hackers=Larry,Damian  :hackers<Larry Damian>

  --good_language         :good_language
  --good_lang=Perl        :good_lang<Perl>
  --bad_lang PHP          :bad_lang<PHP>

  +stuff                  :!stuff
  +stuff=healty           :stuff<healthy> but False

这个地方的 `$x = $obj but False` 的意思是这个 `$x` 是复制的 `$obj`, 但是在布尔上下文时会给出 `Bool::False`.

因此, 对于简单的 (和一些不是很简单的) 情况下, 你并不需要一个外部命令行参数的处理程序, 你可以直播使用 `MAIN` 函数实现这一点.

### [MOTIVATION][159]

这背后的动机应该是很明显的: 它使简单的事情变得更加容易, 很多时候给命令行代码传参只需要简单的 `MAIN` 函数.

### 另请参阅[160]

[http://perlcabal.org/syn/S06.html#Declaring_a_MAIN_subroutine][161] contains the specification.

## Twigils

Mon Oct 20 22:00:00 2008

### [NAME][162]

"Perl 5 to 6" Lesson 15 - Twigils 标记

### 概要[163]

  class Foo {
      has $.bar;
      has $!baz;
  }

  my @stuff = sort { $^b[1] <=> $^a[1]}, [1, 2], [0, 3], [4, 8];
  my $block = { say "This is the named 'foo' parameter: $:foo" };
  $block(:foo<bar>);

  say "This is file $?FILE on line $?LINE"

  say "A CGI script" if %\*ENV.exists('DOCUMENT\_ROOT');

### 描述[164]

在 Perl 6 中有些变量有二个标记, 这个叫 _twigil_ 标记. 如果它存在, 意味着这个变量不是 "标准" 的变量, 它和普通的有些不同, 例如, %*ENV 这个中的 *  表示是全局的, 所以有不同的作用域, 因为默认都不是全局的.

你见到在对象属性中公有和私有分别使用 `.` 和 `!` 的 twigil 标记; 这指出他们不是正常的变量, 他们在这是和 `self` 绑定在一起的变量.

The `^` twigil removes a special case from perl 5. To be able to write

  # beware: perl 5 code
  sort { $a <=> $b } @array

变量 `$a` 和 `$b` 在程序中使用了 `strict` 的时候来讲是个特例. 在 Perl 6 中, 有个概念叫 _self-declared positional parameter_, 这的参数有个 `^` 的标记. 它用于定位块中参数的位置, 它不是参数, 它只是用这些变量根据字母顺序填充位置.

  my $block = { say "$^c $^a $^b" };
  $block(1, 2, 3);                # 3 1 2

所以你现在可以写成: 

  @list = sort { $^b <=> $^a }, @list;
  # or:
  @list = sort { $^foo <=> $^bar }, @list;

在正常的情况下, 用于保持定位和命令参数之间的对称, 在 `:` twigil 也是对命 名参数做同样的事情, 所以这些行相当于:

  my $block = { say $:stuff }
  my $sub   = sub (:$stuff) { say $stuff }

这的 `?` 的 twigil 标记表示在编译的时候就知道的变量和常量, 象 `$?LINE` 是指当前的行的行号( 原 `__LINE__` ), `$?DATA` 是指文件句柄中的 `DATA` 区.

( Contextual variables )上下文变量它是用 `*` 的 twigil 标记来标识, 可以用 `$*` 来访问, 根据上下文的变化而变化的, 先会搜索当前上下文, 再搜索被调用函数的上下文, 以此类推, 所以 `$*IN` 和 `$*OUT` 的输出能动态的覆盖.

有个伪 twigil 是 `<`, 它是象 `$<capture>` 的一个结构, 这是 `$/<capture>` 的简写, 用于访问正则表达式匹配了对象后的 Match object.

### [MOTIVATION][165]

当你读 Perl 5 中的 `perlvar` 文档的时候, 你可以知道, 这有很多的变量, 很多是全局变量, 会影响你的程序.

这的 twigils 会尝试给指定的变量某种顺序, 在另一方面, 他们消除了一些必要的特例. 在对象属性中 twigil 主要用于缩短 `self.var` 到 `$.var`  (or `@.var` or whatever).

所以, 这些虽然增加了一些 "标点符号的噪音" 但实际上使得程序更加一致和可读.

## Enums

Wed Nov 26 23:00:00 2008

### [NAME][166]

"Perl 5 to 6" Lesson 16 - Enums 枚举类型

### 概要[167]

  enum bit Bool <False True>;
  my $value = $arbitrary_value but True;
  if $value {
      say "Yes, it's true";       # will be printed
  }

  enum Day ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');
  if custom_get_date().Day == Day::Sat | Day::Sun {
      say "Weekend";
  }

### 描述[168]

枚举是通用的. 它是低层次类, 它可以包含常量, 整数和字符串.

这些常量可以当成子类型 (subtype), 方法和普通的值. 这些可以通过 `but` 操作符, 加入到对象, which "mixes" the enum into the value:

These constants can act as subtypes, methods or normal values. They can be attached to an object with the `but` operator, which "mixes" the enum into the value:

  my $x = $today but Day::Tue;

你也可以使用枚举类型的名字作为一个函数, 并提供一些值做为参数:

  $x = $today but Day($weekday);

之后这个对象有一个方法, 可以通过枚举类型的名字来调用, 在这是 `Day`:

  say $x.Day;             # 1

第一个常量的值是 0, 接下来是 1 等等, 除非你明确的提供了键值对:

  enum Hackers (:Larry<Perl>, :Guido<Python>, :Paul<Lisp>);

你可以使用智能匹配操作符来检查特定的值. 或者使用 `.does`:

  if $today ~~ Day::Fri {
      say "Thank Christ it's Friday"
  }

  if $today.does(Fri) { ... }

注意, 你可以指定唯一值的名字象 `Fri`. 如果你不确认你需要提供全名, 象 `Day::Fri`.

### [MOTIVATION][169]

Enums replace both the "magic" that is involved with tainted variables in Perl 5 and the `return "0 but True"` hack (a special case for which no warning is emitted if used as a number). Plus they give a `Bool` type.

Enums also provide the power and flexibility of attaching arbitrary meta data for debugging or tracing.

### 另请参阅[170]

<http://perlcabal.org/syn/S12.html#Enumerations>

## Unicode

Thu Nov 27 23:00:00 2008

### [NAME][171]

"Perl 5 to 6" Lesson 17 - Perl 6 的 Unicode 字符编程

### 概要[172]

  (none)

### 描述[173]

Perl 5 中的 Unicode 模型有个大问题: 它对于二进制和文本是使用的相同的类型. 例如, 你的程序从网络上的 socket 套接字上读取了 512 个字节, 它一定是一个 byte 串. 但是在 Perl 5 中对这个调用  `uc` 时, 就会被当成是文本. 推荐的方式是, 先对这个串进行解码, 但是做为子程序, 你接收一个串做为参数时, 你不能可靠的知道, 这到底是被解码了还是没有. 

在 Perl 6 中提供了 `buf` 类型, 这只是 bytes 的集合, 也提供了 `Str`, 这些是 _logical character_ 字符集合.


_logical character_仍然是一个模糊的术语. 为了更加准确的解释 `Str`  的对象, 我们可以见到几个不同的层次: `Byte`, `Codepoint ( 任何 Unicode 的指定的数字都是一个 Codepoint )`, `Grapheme ( 在视觉上显示为一个字符 )` 和  `CharLingua` ( 语言上定义的字符 ).

例如, 字符串通过十六进制表示 `61 cc 80` 是由三个字位元组组成, 但也可以二个 codepoints 组成的名为 `LATIN SMALL LETTER A` (U+0041) 和 `COMBINING GRAVE ACCENT` (U+0300), 或者一个 grapheme , 如果你的浏览器能显示, 它看起来象 `à`.

所以你不能简单地取这个字符串的长度, 你要问一个特定类型的长度:

  $str.bytes;
  $str.codes;
  $str.graphs;

这还有一个方法名为 `chars`, 这是返回当前 Unicode 级别的长度, 你可以通过在程序上给个 `use bytes` 的编译指示来设置为默认 graphemes.

在 Perl 5 中有时很容易错误的串联字符串流和文本字符串. 如果你在 Perl 6 也出现了这个问题, 你可以简单的通过重载连接运算符来简单的识别问题发生在哪.

  sub GLOBAL::infix:<~> is deep (Str $a, buf $b)|(buf $b, Str $a) {
      die "Can't concatenate text string «"
          ~ $a.encode("UTF-8")
            "» with byte string «$b»\\n";
  }

#### [Encoding and Decoding][174]

目前 spec 文档中对于 IO 系统非常的低层, 并没有任何的编码和解码层, 这也是为什么这篇文章没有介绍这个部分, 不过肯定, 很快会有下面这样的一种机制:

  my $handle = open($filename, :r, :encoding<UTF-8>);

#### [Regexes and Unicode][175]

正则表达式可以指定 Unicode level, 所以使用 `m:codes/./` 会匹配到 codepoint. 如果没有指定 Unicode level 会使用当前的 Unicode level.

字符类象 `\w` ( 匹配单词字符 ) 会相应的使用 Unicode 标准. 
Character classes like `\w` (match a word character) behave accordingly to the Unicode standard. There are modifiers that ignore case (`:i`) and accents (`:a`), and modifiers for the substitution operators that can carry case information to the substitution string (`:samecase` and `:sameaccent`, short `:ii`, `:aa`).

### [MOTIVATION][176]

对于大多数编程语言和工具来讲, 能很正确的处理字符是十分困难的. 例如, 在 Perl 5 的 web 应用程序中, 你想使用象 `substr` 来进行字符的切割时, 很有可能它会撕裂整个字符, 变成半个.

Perl 6 会是第一个内置对 grapheme 级别的字符进行操作的编程语言, 这基本上消除了大部分的你对 Unicode 的担忧, 并和正则表达式相结合, 会成为最强大的字符串处理语言.

对于文本和 byte 字符的数据类型的调试和内省会容易多了.

### 另请参阅[177]

<http://perlcabal.org/syn/S32/Str.html>

## Scoping

Fri Nov 28 23:00:00 2008

### [NAME][178]

"Perl 5 to 6" Lesson 18 - Scoping  作用域

### 概要[179]

    for 1 .. 10 -> $a {
        # $a 在这可用 
    }
    # $a 在这不可用 

    while my $b = get_stuff() {
        # $b 在这可用 
    }
    # $b 在这仍然可用 

    my $c = 5;
    {
        my $c = $c;
        # $c 在这是没有定义的 
    }
    # $c 在这是 5 

    my $y;
    my $x = $y + 2 while $y = calc();
    # $x 这仍然可用 

### 描述[180]

#### [Lexical Scoping][181]

Perl 6 中的作用域和 Perl 5 中的比较相似, 一个块会生成一个新的词法范围. 变量名搜索是从最里面的词法范围开始, 如果没有找到, 就查找接下来的外部范围. 就象 Perl 5 中的 `my` 声明的变量是一个词法变量, 如果使用 `our` 声明的其实是引入一个包变量的别名的词法变量.

这也有一些细微的差别: 变量在一个代码块的开始位置声明的, 在块的其它位置都可以见到 ( 例如: 在一个 `while` 循环的条件中 ); 

Perl 6 永远只能查找到词法范围内所限定名称 ( 名称包含变量和函数 ).

如果你想限制作用域, 你可以在块上使用形式参数:

    if calc() -> $result {
        # 你可以在这使用 $result
    }
    # $result 在这就不可用了 

变量在生名后立即可用, 但是 Perl 5 需要在行结尾 ( 可能是分号处 ) 才能使用.

    my $x = .... ;
            ^^^^^
            $x visible here in Perl 6
            but not in Perl 5

#### [Dynamic scoping][182]

原来的 `local` 关键字, 现在叫 `temp`, 使用这个, 如果你没有对这个变量进行初始化, 它这个提供的值是上一个名字空间的原来的值 ( 并不会为 `undef` );

此外还有一种新的被称为 _hypothetical_ 的动态作用域的变量. 如果块中出现了异常, 接下来这个变量会先恢复先前的值, 如果没有, 就保持新的值.

#### [Context variables][183]

在 Perl 5 里, $!, $_ 是全局变量, 但在 Perl6 里就是上下文变量, 就是根据上下文的变化而变化的, 在 Perl6 中就是所谓的动态作用域 (dynamic scoping).

这解决了一个在 Perl 5 中的老问题, 在 Perl 5 中的 `DESTROY` 的子函数可以在一个代码块中被调用来退出, 这个会改变全局的变量, 例如下面的错误.

   # Broken Perl 5 code here:
   sub DESTROY { eval { 1 }; }

   eval {
       my $x = bless {};
       die "Death\\n";
   };
   print $@ if $@;         # No output here

在 Perl 6 中对于这个问题就不在使用隐式的全局变量了.


( 在 Perl 5.14 中, 有其它的方式来保护 `$@` 的修改, 可以避免这种危害 )

#### [伪包]

对于一个块中, 想访问词法变量范围之外 ( 块内访问块外的词法变量 ) 相同名字变量, 可以使用 `OUTER` 这个伪包, 方法如下:

    my $x = 3;
    {
        my $x = 10;
        say $x;             # 10
        say $OUTER::x;      # 3
        say OUTER::<$x>     # 3
    }

同样, 你可以通过 `CALLER` 和 `CONTEXT` 来访问伪包的内容. 这不同之处在于 `CALLER` 只访问最接近的 caller 的命名空间, `CONTEXT` 的工作方式很象 UNIX 的环境变量

Likewise a function can access variables from its caller with the `CALLER` and `CONTEXT` pseudo packages. The difference is that `CALLER` only accesses the scope of the immediate caller, `CONTEXT` works like UNIX environment variables (and should only be used internally by the compiler for handling `$_`, `$!` and the like). To access variables from the outer dynamic scope they must be declared with `is context`.

### [MOTIVATION][185]

我们知道操作和使用全局变量并不好, 会引起很多问题. 我们目前有很多更加好的作用域的机制来实现, 因此, 全局变量仅用于本质上是全局数据, 象 `%*ENV` 或者 `$*PID`.

代码块作用域规则可以极大的简化我们对这些的处理.

下面引用了一段 Perl 5 中 `perlsyn` 的文档, 我不希望 Perl 6 中还有类似的东西:

 NOTE: The behaviour of a "my" statement modified with a statement
 modifier conditional or loop construct (e.g. "my $x if ...") is
 undefined.  The value of the "my" variable may be "undef", any
 previously assigned value, or possibly anything else.  Don't rely on
 it.  Future versions of perl might do something different from the
 version of perl you try it out on.  Here be dragons.

### 另请参阅[186]

S04 discusses block scoping: <http://perlcabal.org/syn/S04.html>.

S02 lists all pseudo packages and explains context scoping: <http://perlcabal.org/syn/S02.html#Names>.

## Regexes strike back

Sat Nov 29 23:00:00 2008

### [NAME][187]

"Perl 5 to 6" Lesson 19 - Regexes strike back

### 概要[188]

    # normal matching:
    if 'abc' ~~ m/../ {
        say $/;                 # ab
    }

    # 匹配通过隐含的 :sigspace 修饰符
    if 'ab cd ef'  ~~ mm/ (..) ** 2 / {
        say $1;                 # cd
    }

    # substitute with the :sigspace modifier
    my $x = "abc     defg";
    $x ~~ ss/c d/x y/;
    say $x;                     # abx     yefg

### 描述[189]

Since the basics of regexes are already covered in lesson 07, here are some useful (but not very structured) additional facts about Regexes.

#### [Matching][190]

You don't need to write grammars to match regexes, the traditional form `m/.../` still works, and has a new brother, the `mm/.../` form, which implies the `:sigspace` modifier. Remember, that means that whitespaces in the regex are substituted by the `<.ws>` rule.

The default for the rule is to match `\s+` if it is surrounded by two word-characters (ie those matching those `\w`), and `\s*` otherwise.

In substitutions the `:samespace` modifier takes care that whitespaces matched with the `ws` rule are preserved. Likewise the `:samecase` modifier, short `:ii` (since it's a variant of `:i`) preserve case.

    my $x = 'Abcd';
    $x ~~ s:ii/^../foo/;
    say $x;                     # Foocd
    $x = 'ABC'
    $x ~~ s:ii/^../foo/;
    say $x                      # FOO

This is very useful if you want to globally rename your module `Foo`, to `Bar`, but for example in environment variables it is written as all uppercase. With the `:ii` modifier the case is automatically preserved.

It copies case information on a character by character. But there's also a more intelligent version; when combined with the `:sigspace` (short `:s`) modifier, it tries to find a pattern in the case information of the source string. Recognized are `.lc`, `.uc`, `.lc.ucfirst`, `.uc.lcfirst` and `.lc.capitaliz` (`Str.capitalize` uppercases the first character of each word). If such a pattern is found, it is also applied to the substitution string.

    my $x = 'The Quick Brown Fox';
    $x ~~ s :s :ii /brown.\*/perl 6 developer/;
    # $x is now 'The Quick Perl 6 Developer'

#### [Alternations][191]

Alternations are still formed with the single bar `|`, but it means something else than in Perl 5. Instead of sequentially matching the alternatives and taking the first match, it now matches all alternatives in parallel, and takes the longest one.

    'aaaa' ~~ m/ a | aaa | aa /;
    say $/                          # aaa

While this might seem like a trivial change, it has far reaching consequences, and is crucial for extensible grammars. Since Perl 6 is parsed using a Perl 6 grammar, it is responsible for the fact that in `++$a` the `++` is parsed as a single token, not as two `prefix:<+>` tokens.

The old, sequential style is still available with `||`:

    grammar Math::Expression {
        token value {
            | <number>
            | '('
              <expression>
              [ ')' || { fail("Parenthesis not closed") } ]
        }

        ...
    }

The `{ ... }` execute a closure, and calling `fail` in that closure makes the expression fail. That branch is guaranteed to be executed only if the previous (here the `')'`) fails, so it can be used to emit useful error messages while parsing.

There are other ways to write alternations, for example if you "interpolate" an array, it will match as an alternation of its values:

    $_ = '12 oranges';
    my @fruits = <apple orange banana kiwi>;
    if m:i:s/ (\d+) (@fruits)s? / {
        say "You've got $0 $1s, I've got \{ $0 + 2 \} of them. You lost.";
    }

There is yet another construct that automatically matches the longest alternation: multi regexes. They can be either written as `multi token name` or with a `proto`:

    grammar Perl {
        ...
        proto token sigil { \* }
        token sigil:sym<$> { <sym> }
        token sigil:sym<@> { <sym> }
        token sigil:sym<%> { <sym> }
        ...

       token variable \{ <sigil> <twigil>? <identifier> \}
   }

This example shows multiple tokens called `sigil`, which are parameterized by `sym`. When the short name, ie `sigil` is used, all of these tokens are matched in an alternation. You may think that this is a very inconvenient way to write an alternation, but it has a huge advantage over writing `'$'|'@'|'%'`: it is easily extensible:

    grammar AddASigil is Perl {
        token sigil:sym<!> { <sym> }
    }
    # wow, we have a Perl 6 grammar with an additional sigil!

Likewise you can override existing alternatives:

    grammar WeirdSigil is Perl \{
        token sigil:sym<$> \{ '°' \}
    \}

In this grammar the sigil for scalar variables is `°`, so whenever the grammar looks for a sigil it searches for a `°` instead of a `$`, but the compiler will still know that it was the regex `sigil:sym<$>` that matched it.

In the next lesson you'll see the development of a real, working grammar with Rakudo.

## A grammar for (pseudo) XML

Fri Dec 5 23:00:00 2008

### [NAME][192]

"Perl 5 to 6" Lesson 20 - A grammar for (pseudo) XML

### 概要[193]

    grammar XML {
        token TOP   { ^ <xml> $ };
        token xml   { <text> [ <tag> <text> ]* };
        token text {  <-[<>&]>* };
        rule tag   {
            '<'(\w+) <attributes>*
            [
                | '/>'                 # a single tag
                | '>'<xml>'</' $0 '>'  # an opening and a closing tag
            ]
        };
        token attributes { \w+ '="' <-["<>]>* '"' };
    };

### 描述[194]

So far the focus of these articles has been the Perl 6 language, independently of what has been implemented so far. To show you that it's not a purely fantasy language, and to demonstrate the power of grammars, this lesson shows the development of a grammar that parses basic XML, and that runs with Rakudo.

Please follow the instructions on <http://rakudo.org/how-to-get-rakudo/> to obtain and build Rakudo, and try it out yourself.

#### [Our idea of XML][195]

For our purposes XML is quite simple: it consists of plain text and nested tags that can optionally have attributes. So here are few tests for what we want to parse as valid "XML", and what not:

    my @tests = (
        [1, 'abc'                       ],      # 1
        [1, '<a></a>'                   ],      # 2
        [1, '..<ab>foo</ab>dd'          ],      # 3
        [1, '<a><b>c</b></a>'           ],      # 4
        [1, '<a href="foo"><b>c</b></a>'],      # 5
        [1, '<a empty="" ><b>c</b></a>' ],      # 6
        [1, '<a><b>c</b><c></c></a>'    ],      # 7
        [0, '<'                         ],      # 8
        [0, '<a>b</b>'                  ],      # 9
        [0, '<a>b</a'                   ],      # 10
        [0, '<a>b</a href="">'          ],      # 11
        [1, '<a/>'                      ],      # 12
        [1, '<a />'                     ],      # 13
    );

    my $count = 1;
    for @tests -> $t \{
        my $s = $t[1];
        my $M = XML.parse($s);
        if !($M  xor $t[0]) \{
            say "ok $count - '$s'";
        \} else \{
            say "not ok $count - '$s'";
        \}
        $count++;
    \}

This is a list of both "good" and "bad" XML, and a small test script that runs these tests by calling `XML.parse($string)`. By convention the rule that matches what the grammar should match is named `TOP`.

(As you can see from test 1 we don't require a single root tag, but it would be trivial to add this restriction).

#### [Developing the grammar][196]

The essence of XML is surely the nesting of tags, so we'll focus on the second test first. Place this at the top of the test script:

    grammar XML \{
        token TOP   \{ ^ <tag> $ \}
        token tag   \{
            '<' (\\w+) '>'
            '</' $0   '>'
        \}
    \};

Now run the script:

    $ ./perl6 xml-01.pl
    not ok 1 - 'abc'
    ok 2 - '<a></a>'
    not ok 3 - '..<ab>foo</ab>dd'
    not ok 4 - '<a><b>c</b></a>'
    not ok 5 - '<a href="foo"><b>c</b></a>'
    not ok 6 - '<a empty="" ><b>c</b></a>'
    not ok 7 - '<a><b>c</b><c></c></a>'
    ok 8 - '<'
    ok 9 - '<a>b</b>'
    ok 10 - '<a>b</a'
    ok 11 - '<a>b</a href="">'
    not ok 12 - '<a/>'
    not ok 13 - '<a />'

So this simple rule parses one pair of start tag and end tag, and correctly rejects all four examples of invalid XML.

The first test should be easy to pass as well, so let's try this:

   grammar XML \{
       token TOP   \{ ^ <xml> $ \};
       token xml   \{ <text> | <tag> \};
       token text  \{ <-[<>&amp;]>\*  \};
       token tag   \{
           '<' (\\w+) '>'
           '</' $0   '>'
       \}
    \};

(Remember, `<-[...]>` is a negated character class.)

And run it:

    $ ./perl6 xml-03.pl
    ok 1 - 'abc'
    not ok 2 - '<a></a>'
    (rest unchanged)

Why in the seven hells did the second test stop working? The answer is that Rakudo doesn't do longest token matching yet (update 2013-01: it does now), but matches sequentially. `<text>` matches the empty string (and thus always), so `<text> | <tag>` never even tries to match `<tag>`. Reversing the order of the two alternations would help.

But we don't just want to match either plain text or a tag anyway, but random combinations of both of them:

    token xml   \{ <text> [ <tag> <text> ]\*  \};

(`[...]` are non-capturing groups, like `(?: ... )` is in Perl 5).

And low and behold, the first two tests both pass.

The third test, `..<ab>foo</ab>dd`, has text between opening and closing tag, so we have to allow that next. But not only text is allowed between tags, but arbitrary XML, so let's just call `<xml>` there:

    token tag   \{
        '<' (\\w+) '>'
        <xml>
        '</' $0   '>'
    \}

    ./perl6 xml-05.pl
    ok 1 - 'abc'
    ok 2 - '<a></a>'
    ok 3 - '..<ab>foo</ab>dd'
    ok 4 - '<a><b>c</b></a>'
    not ok 5 - '<a href="foo"><b>c</b></a>'
    (rest unchanged)

We can now focus on attributes (the `href="foo"` stuff):

    token tag   \{
        '<' (\\w+) <attribute>\* '>'
        <xml>
        '</' $0   '>'
    \};
    token attribute \{
        \\w+ '="' <-["<>]>\* \\"
    \};

But this doesn't make any new tests pass. The reason is the blank between the tag name and the attribute. Instead of adding `\s+` or `\s*` in many places we'll switch from `token` to `rule`, which implies the `:sigspace` modifier:

    rule tag   \{
        '<'(\\w+) <attribute>\* '>'
        <xml>
        '</'$0'>'
    \};
    token attribute \{
        \\w+ '="' <-["<>]>\* \\"
    \};

Now all tests pass, except the last two:

    ok 1 - 'abc'
    ok 2 - '<a></a>'
    ok 3 - '..<ab>foo</ab>dd'
    ok 4 - '<a><b>c</b></a>'
    ok 5 - '<a href="foo"><b>c</b></a>'
    ok 6 - '<a empty="" ><b>c</b></a>'
    ok 7 - '<a><b>c</b><c></c></a>'
    ok 8 - '<'
    ok 9 - '<a>b</b>'
    ok 10 - '<a>b</a'
    ok 11 - '<a>b</a href="">'
    not ok 12 - '<a/>'
    not ok 13 - '<a />'

These contain un-nested tags that are closed with a single slash `/`. No problem to add that to rule `tag`:

    rule tag   \{
        '<'(\\w+) <attribute>\* [
            | '/>'
            | '>' <xml> '</'$0'>'
        ]
    \};

All tests pass, we're happy, our first grammar works well.

#### [More hacking][197]

Playing with grammars is much more fun that reading about playing, so here's what you could implement:

* plain text can contain entities like `&amp;`
* I don't know if XML tag names are allowed to begin with a number, but the current grammar allows that. You might look it up in the XML specification, and adapt the grammar if needed.
* plain text can contain `<![CDATA[ ... ]]>` blocks, in which xml-like tags are ignored and `<` and the like don't need to be escaped
* Real XML allows a preamble like `<?xml version="0.9" encoding="utf-8"?>` and requires one root tag which contains the rest (You'd have to change some of the existing test cases)
* You could try to implement a pretty-printer for XML by recursively walking through the match object `$/`. (This is non-trivial; you might have to work around a few Rakudo bugs, and maybe also introduce some new captures).

(Please don't post solutions to this as comments in this blog; let others have the same fun as you had ;-).

Have fun hacking.

### [MOTIVATION][198]

It's powerful and fun

### 另请参阅[199]

Regexes are specified in great detail in S05: <http://perlcabal.org/syn/S05.html>.

More working examples for grammars can be found at <https://github.com/moritz/json/> (check file lib/JSON/Tiny/Grammar.pm).

## Subset Types

Sat Dec 6 23:00:00 2008

### [NAME][200]

"Perl 5 to 6" Lesson 21 - Subset Types

### 概要[201]

    subset Squares of Int where \{ .sqrt.Int\*\*2 == $\_ \};

    multi sub square\_root(Squares $x --> Int) \{
        return $x.sqrt.Int;
    \}
    multi sub square\_root(Num $x --> Num) \{
        return $x.sqrt;
    \}

### 描述[202]

Java programmers tend to think of a type as either a class or an interface (which is something like a crippled class), but that view is too limited for Perl 6. A type is more generally a constraint of what a values a container can constraint. The "classical" constraint is _it is an object of a class `X` or of a class that inherits from `X`_. Perl 6 also has constraints like _the class or the object does role `Y`_, or _this piece of code returns true for our object_. The latter is the most general one, and is called a _subset_ type:

    subset Even of Int where \{ $\_ % 2 == 0 \}
    # Even can now be used like every other type name

    my Even $x = 2;
    my Even $y = 3; # type mismatch error

(Try it out, Rakudo implements subset types).

You can also use anonymous subtypes in signatures:

    sub foo (Int where \{ ... \} $x) \{ ... \}
    # or with the variable at the front:
    sub foo ($x of Int where \{ ... \} ) \{ ... \}

### [MOTIVATION][203]

Allowing arbitrary type constraints in the form of code allows ultimate extensibility: if you don't like the current type system, you can just roll your own based on subset types.

It also makes libraries easier to extend: instead of dying on data that can't be handled, the subs and methods can simply declare their types in a way that "bad" data is rejected by the multi dispatcher. If somebody wants to handle data that the previous implementation rejected as "bad", he can simple add a multi sub with the same name that accepts the data. For example a math library that handles real numbers could be enhanced this way to also handle complex numbers.

## The State of the implementations

Sun Dec 7 23:00:00 2008

### [NAME][204]

"Perl 5 to 6" Lesson 22 - The State of the implementations

### 概要[205]

    (none)

### 描述[206]

**Note:** This lesson is long outdated, and preserved for historical interest only. The best way to stay informed about various Perl 6 compilers is to follow the blogs at <http://planetsix.perl.org/>.

Perl 6 is a language specification, and multiple compilers are being written that aim to implement Perl 6, and partially they already do.

#### [Pugs][207]

Pugs is a Perl 6 compiler written in Haskell. It was started by Audrey Tang, and she also did most of the work. In terms of implemented features it might still be the most advanced implementation today (May 2009).

To build and test pugs, you have to install GHC 6.10.1 first, and then run

    svn co http://svn.pugscode.org/pugs
    cd pugs
    perl Makefile.PL
    make
    make test

That will install some Haskell dependencies locally and then build pugs. For `make test` you might need to install some Perl 5 modules, which you can do with `cpan Task::Smoke`.

Pugs hasn't been developed during the last three years, except occasional clean-ups of the build system.

Since the specification is evolving and Pugs is not updated, it is slowly drifting into obsoleteness.

Pugs can parse most common constructs, implements object orientation, basic regexes, nearly(?) all control structures, basic user defined operators and macros, many builtins, contexts (except slice context), junctions, basic multi dispatch and the reduction meta operator - based on the syntax of three years past.

#### [Rakudo][208]

Rakudo is a parrot based compiler for Perl 6. The main architect is Patrick Michaud, many features were implemented by Jonathan Worthington.

It is hosted on github, you can find build instructions on <http://rakudo.org/how-to-get-rakudo>.

Rakudo development is very active, it's the most active Perl 6 compiler today. It passes a bit more than 17,000 tests from the official test suite (July 2009).

It implements most control structures, most syntaxes for number literals, interpolation of scalars and closures, chained operators, `BEGIN`- and `END` blocks, pointy blocks, named, optional and slurpy arguments, sophisticated multi dispatch, large parts of the object system, regexes and grammars, Junctions, generic types, parametric roles, typed arrays and hashes, importing and exporting of subroutines and basic meta operators.

If you want to experiment with Perl 6 today, Rakudo is the recommended choice.

#### [Elf][209]

Mitchell Charity started _elf_, a bootstrapping compiler written in Perl 6, with a grammar written in Ruby. Currently it has a Perl 5 backend, others are in planning.

It lives in the pugs repository, once you've checked it out you can go to `misc/elf/` and run `./elf_f $filename`. You'll need ruby-1.9 and some perl modules, about which elf will complain bitterly when they are not present.

`elf` is developed in bursts of activity followed by weeks of low activity, or even none at all.

It parses more than 70% of the test suite, but implements mostly features that are easy to emulate with Perl 5, and passes about 700 tests from the test suite.

#### [KindaPerl6][210]

Flavio Glock started KindaPerl6 (short kp6), a mostly bootstrapped Perl 6 compiler. Since the bootstrapped version is much too slow to be fun to develop with, it is now waiting for a faster backend.

Kp6 implements object orientation, grammars and a few distinct features like lazy gather/take. It also implements `BEGIN` blocks, which was one of the design goals.

#### [v6.pm][211]

`v6` is a source filter for Perl 5. It was written by Flavio Glock, and supports basic Perl 6 plus grammars. It is fairly stable and fast, and is occasionally enhanced. It lives on the CPAN and in the pugs repository in `perl5/*/`.

#### [SMOP][212]

Smop stands for _Simple Meta Object Programming_ and doesn't plan to implement all of Perl 6, it is designed as a backend (a little bit like parrot, but very different in both design and feature set). Unlike the other implementations it aims explicitly at implementing Perl 6's powerful meta object programming facilities, ie the ability to plug in different object systems.

It is implemented in C and various domain specific languages. It was designed and implemented by Daniel Ruoso, with help from Yuval Kogman (design) and Paweł Murias (implementation, DSLs). A grant from The Perl Foundation supports its development, and it currently approaches the stage where one could begin to emit code for it from another compiler.

It will then be used as a backend for either elf or kp6, and perhaps also for pugs.

#### [STD.pm][213]

Larry Wall wrote a grammar for Perl 6 in Perl 6. He also wrote a cheating script named `gimme5`, which translates that grammar to Perl 5. It can parse about every written and valid piece of Perl 6 that we know of, including the whole test suite (apart from a few failures now and then when Larry accidentally broke something).

STD.pm lives in the pugs repository, and can be run and tested with perl-5.10.0 installed in `/usr/local/bin/perl` and a few perl modules (like `YAML::XS` and `Moose`):

    cd src/perl6/
    make
    make testt      # warning: takes lot of time, 80 minutes or so
    ./tryfile $your\_file

It correctly parses custom operators and warns about non-existent subs, undeclared variables and multiple declarations of the same variable as well as about some Perl 5isms.

### [MOTIVATION][214]

Many people ask why we need so many different implementations, and if it wouldn't be better to focus on one instead.

There are basically three answers to that.

Firstly that's not how programming by volunteers work. People sometimes either want to start something with the tools they like, or they think that one aspect of Perl 6 is not sufficiently honoured by the design of the existing implementations. Then they start a new project.

The second possible answer is that the projects explore different areas of the vast Perl 6 language: SMOP explores meta object programming (from which Rakudo will also benefit), Rakudo and parrot care a lot about efficient language interoperability, grammars and platform independence, kp6 explored BEGIN blocks, and pugs was the first implementation to explore the syntax, and many parts of the language for the first time.

The third answer is that we don't want a single point of failure. If we had just one implementation, and had severe problems with one of them for unforeseeable reasons (technical, legal, personal, ...) we have possible fallbacks.

### 另请参阅[215]

Pugs: <http://www.pugscode.org/>, <http://pugs.blogs.com/pugs/2008/07/pugshs-is-back.html>, <http://pugs.blogspot.com>, source: <http://svn.pugscode.org/pugs>.

Rakudo: <http://rakudo.org/>, <http://www.parrot.org/>,

Elf: <http://perl.net.au/wiki/Elf> source: see pugs, `misc/elf/`.

KindaPerl6: source: see pugs, `v6/v6-KindaPerl6`.

v6.pm: source: see pugs, `perl5/`.

STD.pm: source: see pugs, `src/perl6/`.

## Quoting and Parsing

Mon Dec 8 23:00:00 2008

### [NAME][216]

"Perl 5 to 6" Lesson 23 - Quoting and Parsing

### 概要[217]

    my @animals = <dog cat tiger>
    # or
    my @animals = qw/dog cat tiger/;
    # or

    my $interface = q\{eth0\};
    my $ips = q :s :x /ifconfig $interface/;

    # -----------

    sub if \{
        warn "if() calls a sub\\n";
    \}
    if();

### 描述[218]

#### [Quoting][219]

Perl 6 has a powerful mechanism of quoting strings, you have exact control over what features you want in your string.

Perl 5 had single quotes, double quotes and `qw(...)` (single quotes, splitted on whitespaces) as well as the `q(..)` and `qq(...)` forms which are basically synonyms for single and double quotes.

Perl 6 in turn defines a quote operator named `Q` that can take various modifiers. The `:b` (_backslash_) modifier allows interpolation of backslash escape sequences like `\n`, the `:s` modifier allows interpolation of scalar variables, `:c` allows the interpolation of closures (`"1 + 2 = { 1 + 2 }"`) and so on, `:w` splits on words as `qw/.../` does.

You can arbitrarily combine those modifiers. For example you might wish a form of `qw/../` that interpolates only scalars, but nothing else? No problem:

    my $stuff = "honey";
    my @list = Q :w :s/milk toast $stuff with\\tfunny\\nescapes/;
    say @list[\*-1];                     # prints with\\nfunny\\nescapes

Here's a list of what modifiers are available, mostly stolen from S02 directly. All of these also have long names, which I omitted here.

    Features:
        :q          Interpolate \\\\, \\q and \\'
        :b          Other backslash escape sequences like \\n, \\t
    Operations:
        :x          Execute as shell command, return result
        :w          Split on whitespaces
        :ww         Split on whitespaces, with quote protection
    Variable interpolation
        :s          Interpolate scalars   ($stuff)
        :a          Interpolate arrays    (@stuff[])
        :h          Interpolate hashes    (%stuff\{\})
        :f          Interpolate functions (&amp;stuff())
    Other
        :c          Interpolate closures  (\{code\})
        :qq         Interpolate with :s, :a, :h, :f, :c, :b
        :regex      parse as regex

There are some short forms which make life easier for you:

    q       Q:q
    qq      Q:qq
    m       Q:regex

You can also omit the first colon `:` if the quoting symbol is a short form, and write it as a singe word:

    symbol      short for
    qw          q:w
    Qw          Q:w
    qx          q:x
    Qc          Q:c
    # and so on.

However there is one form that does not work, and some Perl 5 programmers will miss it: you can't write `qw(...)` with the round parenthesis in Perl 6. It is interpreted as a call to sub `qw`.

#### [Parsing][220]

This is where parsing comes into play: Every construct of the form `identifier(...)` is parsed as sub call. Yes, every.

    if($x<3)

is parsed as a call to sub `if`. You can disambiguate with whitespaces:

    if ($x < 3) \{ say '<3' \}

Or just omit the parens altogether:

    if $x < 3 \{ say '<3' \}

This implies that Perl 6 has no keywords. Actually there are keywords like `use` or `if`, but they are only special if used in a special syntax.

### [MOTIVATION][221]

Various combinations of the quoting modifiers are already used internally, for example `q:w` to parse `<...>`, and `:regex` for `m/.../`. It makes sense to expose these also to the user, who gains flexibility, and can very easily write macros that provide a shortcut for the exact quoting semantics he wants.

And when you limit the specialty of keywords, you have far less troubles with backwards compatibility if you want to change what you consider a "keyword".

### 另请参阅[222]

<http://perlcabal.org/syn/S02.html#Literals>

## The Reduction Meta Operator

Tue Dec 9 23:00:00 2008

### [NAME][223]

"Perl 5 to 6" Lesson 24 - The Reduction Meta Operator

### 概要[224]

    say [+] 1, 2, 3;    # 6
    say [+] ();         # 0
    say [~] <a b>;      # ab
    say [\*\*] 2, 3, 4;   # 2417851639229258349412352

    [\\+] 1, 2, 3, 4     # 1, 3, 6, 10
    [\\\*\*] 2, 3, 4       # 4, 81, 2417851639229258349412352

    if [<=] @list \{
        say "ascending order";
    \}

### [Description][225]

The reduction meta operator `[...]` can enclose any associative infix operator, and turn it into a list operator. This happens as if the operator was just put between the items of the list, so `[op] $i1, $i2, @rest` returns the same result as if it was written as `$i1 op $i2 op @rest[0] op @rest[1] ...`.

This is a very powerful construct that promotes the plus `+` operator into a `sum` function, `~` into a `join` (with empty separator) and so on. It is somewhat similar to the `List.reduce` function, and if you had some exposure to functional programming, you'll probably know about `foldl` and `foldr` (in Lisp or Haskell). Unlike those `[...]` respects the associativity of the enclosed operator, so `[/] 1, 2, 3` is interpreted as `(1 / 2) / 3` (left associative), `[**] 1, 2, 3` is handled correctly as `1 ** (2**3)` (right associative).

Like all other operators whitespaces are forbidden, so you while you can write `[+]`, you can't say `[ + ]`.

Since comparison operators can be chained, you can also write things like

    if    [==] @nums \{ say "all nums in @nums are the same" \}
    elsif [<]  @nums \{ say "@nums is in strict ascending order" \}
    elsif [<=] @nums \{ say "@nums is in ascending order"\}

You can even reduce the assignment operator:

    my @a = 1..3;
    [=] @a, 4;          # same as @a[0] = @a[1] = @a[2] = 4;

Note that `[...]` always returns a scalar, so `[,] @list` is actually the same as `[@list]`.

#### [Getting partial results][226]

There's a special form of this operator that uses a backslash like this: `[\+]`. It returns a list of the partial evaluation results. So `[\+] 1..3` returns the list `1, 1+2, 1+2+3`, which is of course `1, 3, 6`.

    [\\~] 'a' .. 'd'     # <a ab abc abcd>

Since right-associative operators evaluate from right to left, you also get the partial results that way:

    [\\\*\*] 1..3;         # 3, 2\*\*3, 1\*\*(2\*\*3), which is 3, 8, 1

Multiple reduction operators can be combined:

    [~] [\\\*\*] 1..3;     # "381"

### [MOTIVATION][227]

Programmers are lazy, and don't want to write a loop just to apply a binary operator to all elements of a list. `List.reduce` does something similar, but it's not as terse as the meta operator (`[+] @list` would be `@list.reduce(&infix:<+>)`), and takes care of the associativity of the operator.

If you're not convinced, play a bit with it (pugs mostly implements it), it's real fun.

### 另请参阅[228]

[http://perlcabal.org/syn/S03.html#Reduction\_operators][229], [http://www.perlmonks.org/?node\_id=716497][230]

## The Cross Meta Operator

Tue May 26 22:00:00 2009

### [NAME][231]

"Perl 5 to 6" Lesson 25 - The Cross Meta Operator

### 概要[232]

    for <a b> X 1..3 -> $a, $b \{
        print "$a: $b   ";
    \}
    # output: a: 1  a: 2  a: 3  b: 1  b: 2  b: 3

    .say for <a b c> X 1, 2;
    # output: a1\\n a2\\n b1\\n b2\\n c1\\n c2\\n
    # (with real newlines instead of \\n)

### 描述[233]

The cross operator `X` returns the Cartesian product of two or more lists, which means that it returns all possible tuples where the first item is an item of the first list, the second item is an item of second list etc.

If an operator follows the `X`, then this operator is applied to all tuple items, and the result is returned instead. So `1, 2 X+ 3, 6` will return the values `1+3, 1+6, 2+3, 2+6` (evaluated as `4, 7, 5, 8` of course).

### [MOTIVATION][234]

It's quite common that one has to iterate over all possible combinations of two or more lists, and the cross operator can condense that into a single iteration, thus simplifying programs and using up one less indentation level.

The usage as a meta operator can sometimes eliminate the loops altogether.

### 另请参阅[235]

[http://perlcabal.org/syn/S03.html#Cross\_operators][236],

## Exceptions and control exceptions

Thu Jul 9 09:00:02 2009

### [NAME][237]

"Perl 5 to 6" Lesson 26 - Exceptions and control exceptions

### 概要[238]

    try \{
        die "OH NOEZ";

        CATCH \{
            say "there was an error: $!";
        \}
    \}

### 描述[239]

Exceptions are, contrary to their name, nothing exceptional. In fact they are part of the normal control flow of programs in Perl 6.

Exceptions are generated either by implicit errors (for example dividing by zero, calling a non-existing method, type check failures) or by explicitly calling `die` or other functions.

When an exception is thrown, the program searches for `CATCH` statements or `try` blocks in the caller frames, unwinding the stack all the way (that means it forcibly returns from all routines called so far). If no `CATCH` or `try` is found, the program terminates, and prints out a hopefully helpful error message. If one was found, the error message is stored in the special variable `$!`, and the `CATCH` block is executed (or in the case of a `try` without a CATCH block the try block returns `undef`).

So far exceptions might still sound exceptional, but error handling is integral part of each non-trivial application. But even more, normal `return` statements also throw exceptions!

They are called _control exceptions_, and can be caught with `CONTROL` blocks, or are implicitly caught at each routine declaration.

Consider this example:

    use v6;
    my $block = -> \{ return "block"; say "still here" \};

    sub s \{
        $block.();
        return "sub";
    \}

    say s();

Here the `return "block"` throws a control exception, causing it to not only exit the current block (and thus not printing `still here` on the screen), but also exiting the subroutine, where it is caught by the `sub s...` declaration. The payload, here a string, is handed back as the return value, and the `say` in the last line prints it to the screen.

Embedding the call `$block.()` in a `try { ... }` block or adding a `CONTROL { ... }` block to the body of the routine causes it to catch the exception.

Contrary to what other programming languages do, the `CATCH`/`CONTROL` blocks are within the scope in which the error is caught (not on the outside), giving it full access to the lexical variables, which makes it easier to generate useful error message, and also prevents DESTROY blocks from being run before the error is handled.

#### [Unthrown exceptions][240]

Perl 6 embraces the idea of multi threading, and in particular automated parallelization. To make sure that not all threads suffer from the termination of a single thread, a kind of "soft" exception was invented.

When a function calls `fail($obj)`, it returns a special value of `undef`, which contains the payload `$obj` (usually an error message) and the back trace (file name and line number). Processing that special undefined value without check if it's undefined causes a normal exception to be thrown.

    my @files = </etc/passwd /etc/shadow nonexisting>;
    my @handles = hyper map \{ open($\_) \}, @files;

In this example the `hyper` operator tells `map` to parallelize its actions as far as possible. When the opening of the `nonexisting` file fails, an ordinary `die "No such file or directory"` would also abort the execution of all other `open` operations. But since a failed open calls `fail("No such file or directory"` instead, it gives the caller the possibility to check the contents of `@handles`, and it _still has access to the full error message_.

If you don't like soft exceptions, you say `use fatal;` at the start of the program and cause all exceptions from `fail()` to be thrown immediately.

### [MOTIVATION][241]

A good programming language needs exceptions to handle error conditions. Always checking return values for success is a plague and easily forgotten.

Since traditional exceptions can be poisonous for implicit parallelism, we needed a solution that combined the best of both worlds: not killing everything at once, and still not losing any information.

## Common Perl 6 data processing idioms

Thu Jul 22 13:34:26 2010

### [NAME][242]

"Perl 5 to 6" Lesson 27 - Common Perl 6 data processing idioms

### 概要[243]

  # create a hash from a list of keys and values:
  # solution 1: slices
  my %hash; %hash\{@keys\} = @values;
  # solution 2: meta operators
  my %hash = @keys Z=> @values;

  # create a hash from an array, with
  # true value for each array item:
  my %exists = @keys Z=> 1 xx \*;

  # limit a value to a given range, here 0..10.
  my $x = -2;
  say 0 max $x min 10;

  # for debugging: dump the contents of a variable,
  # including its name, to STDERR
  note :$x.perl;

  # sort case-insensitively
  say @list.sort: \*.lc;

  # mandatory attributes
  class Something \{
      has $.required = die "Attribute 'required' is mandatory";
  \}
  Something.new(required => 2); # no error
  Something.new()               # BOOM

### 描述[244]

Learning the specification of a language is not enough to be productive with it. Rather you need to know how to solve specific problems. Common usage patterns, called _idioms_, helps you not having to re-invent the wheel every time you're faced with a problem.

So here a some common Perl 6 idioms, dealing with data structures.

#### [Hashes][245]

  # create a hash from a list of keys and values:
  # solution 1: slices
  my %hash; %hash\{@keys\} = @values;
  # solution 2: meta operators
  my %hash = @keys Z=> @values;

The first solution is the same you'd use in Perl 5: assignment to a slice. The second solution uses the zip operator `Z`, which joins to list like a zip fastener: `1, 2, 3 Z 10, 20, 30` is `1, 10, 2, 20, 3, 30`. The `Z=>` is a meta operator, which combines zip with `=>` (the Pair construction operator). So `1, 2, 3 Z=> 10, 20, 30` evaluates to `1 => 10, 2 => 20, 3 => 30`. Assignment to a hash variable turns that into a Hash.

For existence checks, the values in a hash often doesn't matter, as long as they all evaluate to `True` in boolean context. In that case, a nice way to initialize the hash from a given array or list of keys is

  my %exists = @keys Z=> 1 xx \*;

which uses a lazy, infinite list of 1s on the right-hand side, and relies on the fact that `Z` ends when the shorter list is exhausted.

#### [Numbers][246]

Sometimes you want to get a number from somewhere, but clip it into a predefined range (for example so that it can act as an array index).

In Perl 5 you often end up with things like `$a = $b > $upper ? $upper : $b`, and another conditional for the lower limit. With the `max` and `min` infix operators, that simplifies considerably to

  my $in-range = $lower max $x min $upper;

because `$lower max $x` returns the larger of the two numbers, and thus clipping to the lower end of the range.

Since `min` and `max` are infix operators, you can also clip infix:

 $x max= 0;
 $x min= 10;

#### [Debugging][247]

Perl 5 has Data::Dumper, Perl 6 objects have the `.perl` method. Both generate code that reproduces the original data structure as faithfully as possible.

`:$var` generates a Pair ("colonpair"), using the variable name as key (but with sigil stripped). So it's the same as `var => $var`. `note()` writes to the standard error stream, appending a newline. So `note :$var.perl` is quick way of obtaining the value of a variable for debugging; purposes, along with its name.

#### [Sorting][248]

Like in Perl 5, the `sort` built-in can take a function that compares two values, and then sorts according to that comparison. Unlike Perl 5, it's a bit smarter, and automatically does a transformation for you if the function takes only one argument.

In general, if you want to compare by a transformed value, in Perl 5 you can do:

    # WARNING: Perl 5 code ahead
    my @sorted = sort \{ transform($a) cmp transform($b) \} @values;

    # or the so-called Schwartzian Transform:
    my @sorted = map \{ $\_->[1] \}
                 sort \{ $a->[0] cmp $b->[0] \}
                 map \{ [transform($\_), $\_] \}
                 @values

The former solution requires repetitive typing of the transformation, and executes it for each comparison. The second solution avoids that by storing the transformed value along with the original value, but it's quite a bit of code to write.

Perl 6 automates the second solution (and a bit more efficient than the naiive Schwartzian transform, by avoiding an array for each value) when the transformation function has arity one, ie accepts one argument only:

    my @sorted = sort &amp;transform, @values;

#### [Mandatory Attributes][249]

The typical way to enforce the presence of an attribute is to check its presence in the constructor - or in all constructors, if there are many.

That works in Perl 6 too, but it's easier and safer to require the presence at the level of each attribute:

    has $.attr = die "'attr' is mandatory";

This exploits the default value mechanism. When a value is supplied, the code for generating the default value is never executed, and the `die` never triggers. If any constructor fails to set it, an exception is thrown.

### [MOTIVATION][250]

N/A

## Currying

Sun Jul 25 09:17:10 2010

### [NAME][251]

"Perl 5 to 6" Lesson 28 - Currying

### 概要

  use v6;

  my &amp;f := &amp;substr.assuming('Hello, World');
  say f(0, 2);                # He
  say f(3, 2);                # lo
  say f(7);                   # World

  say <a b c>.map: \* x 2;     # aabbcc
  say <a b c>.map: \*.uc;      # ABC
  for ^10 \{
      print <R G B>.[$\_ % \*]; # RGBRGBRGBR
  \}

### 描述

_Currying_ or _partial application_ is the process of generating a function from another function or method by providing only some of the arguments. This is useful for saving typing, and when you want to pass a callback to another function.

Suppose you want a function that lets you extract substrings from `"Hello, World"` easily. The classical way of doing that is writing your own function:

  sub f(\*@a) \{
      substr('Hello, World', |@a)
  \}

#### [Currying with `assuming`][254]

Perl 6 provides a method `assuming` on code objects, which applies the arguments passed to it to the invocant, and returns the partially applied function.

  my &amp;f := &amp;substr.assuming('Hello, World');

Now `f(1, 2)` is the same as `substr('Hello, World', 1, 2)`.

`assuming` also works on operators, because operators are just subroutines with weird names. To get a subroutine that adds 2 to whatever number gets passed to it, you could write

  my &amp;add\_two := &amp;infix:<+>.assuming(2);

But that's tedious to write, so there's another option.

#### [Currying with the Whatever-Star][255]

  my &amp;add\_two := \* + 2;
  say add\_two(4);         # 6

The asterisk, called _Whatever_, is a placeholder for an argument, so the whole expression returns a closure. Multiple Whatevers are allowed in a single expression, and create a closure that expects more arguments, by replacing each term `*` by a formal parameter. So `* * 5 + *` is equivalent to `-> $a, $b { $a * 5 + $b }`.

  my $c = \* \* 5 + \*;
  say $c(10, 2);                # 52

Note that the second `*` is an infix operator, not a term, so it is not subject to Whatever-currying.

The process of lifting an expression with Whatever stars into a closure is driven by syntax, and done at compile time. This means that

  my $star = \*;
  my $code = $star + 2

does not construct a closure, but instead dies with a message like

  Can't take numeric value for object of type Whatever

Whatever currying is more versatile than `.assuming`, because it allows to curry something else than the first argument very easily:

  say  ~(1, 3).map: 'hi' x \*    # hi hihihi

This curries the second argument of the string repetition operator infix `x`, so it returns a closure that, when called with a numeric argument, produces the string `hi` as often as that argument specifies.

The invocant of a method call can also be Whatever star, so

  say <a b c>.map: \*.uc;      # ABC

involves a closure that calls the `uc` method on its argument.

### [MOTIVATION][256]

Perl 5 could be used for functional programming, which has been demonstrated in Mark Jason Dominus' book _Higher Order Perl_.

Perl 6 strives to make it even easier, and thus provides tools to make typical constructs in functional programming easily available. Currying and easy construction of closures is a key to functional programming, and makes it very easy to write transformation for your data, for example together with `map` or `grep`.

### 另请参阅[257]

[http://perlcabal.org/syn/S02.html#Built-In\_Data\_Types][258]

<http://hop.perl.plover.com/>

<http://en.wikipedia.org/wiki/Currying>

 Copyright 2008 - 2013: Moritz Lenz<br /> This page may be used under the terms of the [Creative Commons Attribution 3.0 Germany License][259]. Please place a link to the pages you use for your derivative work. <br /> Layout based on [YAML][260], powered by [mowyw][261]

  [17]: #post_00
  [18]: #post_01
  [19]: #post_02
  [20]: #post_03
  [21]: #post_04
  [22]: #post_05
  [23]: #post_06
  [24]: #post_07
  [25]: #post_08
  [26]: #post_09
  [27]: #post_10
  [28]: #post_11
  [29]: #post_12
  [30]: #post_13
  [31]: #post_14
  [32]: #post_15
  [33]: #post_16
  [34]: #post_17
  [35]: #post_18
  [36]: #post_19
  [37]: #post_20
  [38]: #post_21
  [39]: #post_22
  [40]: #post_23
  [41]: #post_24
  [42]: #post_25
  [43]: #post_26
  [44]: #post_27
  [45]: #post_28
  [46]: 
  [47]: 
  [48]: 
  [49]: 
  [50]: 
  [51]: 
  [52]: 
  [53]: 
  [54]: 
  [55]: 
  [56]: 
  [57]: 
  [58]: 
  [59]: 
  [60]: 
  [61]: 
  [62]: 
  [63]: 
  [64]: 
  [65]: 
  [66]: 
  [67]: 
  [68]: 
  [69]: 
  [70]: http://perlcabal.org/syn/S02.html#Built-In_Data_Types
  [71]: 
  [72]: 
  [73]: 
  [74]: 
  [75]: 
  [76]: 
  [77]: http://perlcabal.org/syn/S04.html#Conditional_statements
  [78]: 
  [79]: 
  [80]: 
  [81]: 
  [82]: 
  [83]: 
  [84]: 
  [85]: 
  [86]: http://en.wikipedia.org/wiki/Schwartzian_transform
  [87]: 
  [88]: 
  [89]: 
  [90]: 
  [91]: 
  [92]: 
  [93]: 
  [94]: 
  [95]: 
  [96]: http://en.wikipedia.org/wiki/Perl_6#Roles
  [97]: 
  [98]: 
  [99]: 
  [100]: 
  [101]: 
  [102]: 
  [103]: 
  [104]: 
  [105]: 
  [106]: 
  [107]: 
  [108]: 
  [109]: 
  [110]: 
  [111]: 
  [112]: 
  [113]: 
  [114]: 
  [115]: 
  [116]: 
  [117]: 
  [118]: 
  [119]: 
  [120]: http://perlcabal.org/syn/S03.html#Junctive_operators
  [121]: 
  [122]: 
  [123]: 
  [124]: 
  [125]: 
  [126]: http://perlcabal.org/syn/S03.html#Smart_matching
  [127]: 
  [128]: 
  [129]: 
  [130]: 
  [131]: 
  [132]: http://perlcabal.org/syn/S03.html#Item_assignment_precedence
  [133]: 
  [134]: 
  [135]: 
  [136]: 
  [137]: 
  [138]: http://perlcabal.org/syn/S03.html#Changes_to_Perl_5_operators
  [139]: 
  [140]: 
  [141]: 
  [142]: 
  [143]: 
  [144]: 
  [145]: 
  [146]: 
  [147]: 
  [148]: 
  [149]: 
  [150]: 
  [151]: 
  [152]: 
  [153]: 
  [154]: 
  [155]: http://perlcabal.org/syn/S06.html#Operator_overloading
  [156]: 
  [157]: 
  [158]: 
  [159]: 
  [160]: 
  [161]: http://perlcabal.org/syn/S06.html#Declaring_a_MAIN_subroutine
  [162]: 
  [163]: 
  [164]: 
  [165]: 
  [166]: 
  [167]: 
  [168]: 
  [169]: 
  [170]: 
  [171]: 
  [172]: 
  [173]: 
  [174]: 
  [175]: 
  [176]: 
  [177]: 
  [178]: 
  [179]: 
  [180]: 
  [181]: 
  [182]: 
  [183]: 
  [184]: 
  [185]: 
  [186]: 
  [187]: 
  [188]: 
  [189]: 
  [190]: 
  [191]: 
  [192]: 
  [193]: 
  [194]: 
  [195]: 
  [196]: 
  [197]: 
  [198]: 
  [199]: 
  [200]: 
  [201]: 
  [202]: 
  [203]: 
  [204]: 
  [205]: 
  [206]: 
  [207]: 
  [208]: 
  [209]: 
  [210]: 
  [211]: 
  [212]: 
  [213]: 
  [214]: 
  [215]: 
  [216]: 
  [217]: 
  [218]: 
  [219]: 
  [220]: 
  [221]: 
  [222]: 
  [223]: 
  [224]: 
  [225]: 
  [226]: 
  [227]: 
  [228]: 
  [229]: http://perlcabal.org/syn/S03.html#Reduction_operators
  [230]: http://www.perlmonks.org/?node_id=716497
  [231]: 
  [232]: 
  [233]: 
  [234]: 
  [235]: 
  [236]: http://perlcabal.org/syn/S03.html#Cross_operators
  [237]: 
  [238]: 
  [239]: 
  [240]: 
  [241]: 
  [242]: 
  [243]: 
  [244]: 
  [245]: 
  [246]: 
  [247]: 
  [248]: 
  [249]: 
  [250]: 
  [251]: 
  [252]: 
  [253]: 
  [254]: 
  [255]: 
  [256]: 
  [257]: 
  [258]: http://perlcabal.org/syn/S02.html#Built-In_Data_Types
  [259]: http://creativecommons.org/licenses/by/3.0/de/
  [260]: http://www.yaml.de/
  [261]: /en/software/mowyw
