## 2010 年 Perl6 圣诞月历(廿一)翻译以及其他~

翻译( Transliteration )一听就像是有一个拉丁文的词根，然后开始转换字母。嗯，这就是 `Str.trans` 方法要做的。

    say "GATTACA".trans( "TCAG" => "0123" );  # prints "3200212\n"

写 shell 或者 perl5 的童鞋可能马上想到了 `tr/tcag/0123/` 这个写法。这里快速的解释一下 trans ：我们把字符串里每一个 T 换成 0，每一个 C 换成 1 ……也就是说，这两个 TCAG 和 0123 是会分成一个一个字母的进行替换的。

这可以用来做一些很节省时间的事情。比如，下面是一个用回转 13 位法加密文本的例子：

    sub rot13($text) { $text.trans( "A..Za..z" => "N..ZA..Mn..za..m" ) }

当 `.trans` 看到 `..` 操作符的时候，会自动展开（比如把 n..z 变成 nopqrstuvwxyz ）。所以，回转 13 位加密法的最终结果就是转换一部分字母成刚好相反的另一部分。

在 Perl5 里，两个点 .. 只是一个破折号 - 的概念。在 Perl6 里，我们准备扩展成范围( range )的概念。不管是主程序、正则表达式，还是翻译语句里。

同时你可以注意到： `.trans` 方法不会改变 `$text` 变量本身的值，而是返回一个新的值。这也是 Perl6 中的普遍做法。在 Perl6 的主核里，我们更偏向提供这些没副作用的方法。当然你只要稍微修改一点点，写成 `.=trans` ，就可以直接改变变量本身了。

    $kabbala.=trans("A..Ia..i" => "1..91..9");

(这个用法同样也不是 `.trans` 唯一的，所有的方法都可以这么用。意在鼓励程序员们采用非变更的方式编写自己的库，世界都会美好很多的^-^)

如果 Perl6 的 `.trans` 技止于此，那 Perl6 还不如叫回 Perl5 得了~继续看示例：

    #当你要写一个html页的时候，肯定需要这么个转换吧
        & => &amp;
        < => &lt;
        > => &gt;

(顺便说一下：如果真是要写 html 了，我们有写好的库直接可以用。这里只是要你把握一个原则，当你要完成类似工作的是，Perl6 已经内置了功能可以用的。)

看起来不是一个简单的正则就能搞定的事情。为什么呢？以为替换前后都有一个 `&`，很可能会变成一个无限循环，就像这样：`&=>&=>&&=>&&&` …你可能要写一大把代码来避免这种情况的发生了。

事实上，这根本不是什么问题。这个需求的本质，是字符串的拼接，用不着拔高到思想的高度去。我们可不想要一个换下次序就不顶用的解决方案。好比说下面这个：

        foo         => bar
        foolishness => folly

匹配完第一个，后面这个就不会生效了——这可不行。所以一般情况下，我们会按照先长后短的方式书写。

总之，我们需要的是一个最长标记的替换匹配，这样才不会导致无限循环的错误。

而这就是 Perl6 的 `.trans` 提供的！真正的杀手锏：提供一对数组，而不单单是字符串。比如这个 HTML 的转义需求，我们只需要这么写就可以了：

    my $escaped = $html.trans(
        [ '&',     '<',    '>'    ] =>
        [ '&amp;', '&lt;', '&gt;' ]
    );

perl6 会按照正确的顺序进行替换，绝对没有什么循环的麻烦。享受吧~~

