pmichaud 在昨天介绍了 Perl 6 的 hyper 运算符,我这要进一步来探索 Perl6 中强大的元操作的特性.
首先,为简单起见,我将编写一个 lsay 的函数,可以轻松地得到好看的列表值的输出.这个 sub 是用我们用 Perl 来创建的

```
our sub lsay(@a) { @a.perl.say }
```

注:因为新的 Perl6 可以命令行直接显示变量内容,所以我下面的例子代码修改了不使用这个子函数

接下来我们看 hyperoperator 的例子.在这个中,我们使用 >> 和 << 来替换 » 和 «,主要因为这样更加容易看(我怕我会需要眼镜).»和« 是语言中真实的形式,但较长的 ASCII 字符版本也是可以正常工作的.

首先.来个基本的:
添加二个相同长度的列表

```
> (1, 2, 3, 4) <<+>> (3, 1, 3, 1)
[4, 3, 6, 5]
> (1, 2, 3, 4) >>+<< (3, 1, 3, 1)
[4, 3, 6, 5]
```

注：上面一定要修改成列表上下文才行,新版本可能去掉了自动转换列表上下文件转换,所以上面的会出错,需要修改成 lsay(@( (1,2,3,4) <<+>> (3,1,3,1))) 来强行上下文转换. Perl6 中显示指明上下文为列表的语法为 @( stuff ) List context.我的译文上面是直接去掉了 lsay 的转换,所以大家可以参考原文.

如果数组的长度是相同的,上面这两种形式之间没有区别.但是,如果长度是不同的：

```
> (1, 2, 3, 4) <<+>> (3, 1)
[4, 3, 4, 5]
> (1, 2, 3, 4) >>+<< (3, 1)
Sorry, lists on both sides of non-dwimmy hyperop are not of same length:
left: 4 elements, right: 2 elements
``` 

注： 同上,最新的 Rakudo 中要进行列表上下文转换.lsay(@((1, 2, 3, 4) <<+>> (3, 1)))
这规则是, 象诸如此类的尖尖是用来表明 hyperoperator 使用时,当一端比另一端短,可以延长短的那一端来进行扩展延伸;扩展短的那端的方法是从最后开始重复列表中的元素.
象如果是尖尖指向内部,是指不能进行扩展延伸.当然,还可以有各种组合都是可以的.所以你也能指出只有左边能扩展延伸 (<<+<<),也可以只指出只有右边能(>>+>>).当然也能二边都是可以扩展延伸 (<<+>>),或者二边都不能扩展延伸 (>>+<<).
单标量扩展延伸如下：

```
> (1, 2, 3, 4) >>+>> 2
[3, 4, 5, 6]
> 3 <<+<< (1, 2, 3, 4)
[4, 5, 6, 7]
```

因此,这就是基本的使用中缀操作符 hyperoperator 的方法.您还可以使用前缀和后缀运算符：

```
> ~<<(1, 2, 3, 4)
["1", "2", "3", "4"]
> my @a= (1, 2, 3, 4); @a>>++; @a;
[2, 3, 4, 5]
``` 

你也能这样:

```
> (0, pi/4, pi/2, pi, 2*pi)>>.sin
[0, 0.707106781186547, 1, 1.22464679914735e-16, -2.44929359829471e-16]
> (-1, 0, 3, 42)>>.Str
["-1", "0", "3", "42"]
```

这其实就是只是想说 >>. 是调用列表中的每一个成员的一种方法

无论你是否想和不想写 @array>>.say .但在当前版本的Rakudo的,但使用 Hyper 操作符,你的操作是并行的,但 list(s) 的列表操作顺序是不固定的.希望,在未来版本的 Perl 6 会自动并行正确运行这些操作.
注：目前我测试是可以正常工作

其他说明：hyperoperators 并不只是只能和内置操作符一起工作.他们也将能跟你定义以及任何新的运算符工作的很好（即大多数的的都能正常在现在的 Rakudo 上工作）.只要给放在适当的地方.如@a >>/=>>2 整个数组成员都除以 2. 他们将来能和更多的结构一起工作,如多维列表,树与哈希;我们可 [S03 Hyper operators](http://perlcabal.org/syn/S03.html#Hyper_operators).(据我所知,有些功能还尚未在 Rakudo 正常实现)

我并不知道是否有很多代码示例中广泛使用 hyperoperators. 但 LastOfTheCarelessMen’s [Vector](https://github.com/LastOfTheCarelessMen/Vector/blob/master/lib/Vector.pm) 是一个非常好的实现.它使用单循环直接的实现了一个 N 维向量类.
